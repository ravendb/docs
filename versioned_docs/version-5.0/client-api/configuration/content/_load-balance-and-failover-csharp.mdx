import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* The `ReadBalanceBehavior` convention gets or sets the default load-balancing 
  behavior of ***Read*** requests from the client to RavenDB cluster.  

     The selected method determines which node the client's `RequestExecutor` would 
     send ***Read*** requests to, and which node to *failover* to in case of issues 
     with the ***Read*** request.  

* ***Write*** requests are sent to the 
  [Preferred Node](../../../client-api/configuration/load-balance-and-failover.mdx#preferred-node) 
  calculated by the client.  

* The `LoadBalanceBehavior` convention can determine that the topology would 
  be specified by a client session.  

* In this page:  
  * [ReadBalanceBehavior Options](../../../client-api/configuration/load-balance-and-failover.mdx#readbalancebehavior-options)  
  * [Preferred Node](../../../client-api/configuration/load-balance-and-failover.mdx#preferred-node) 
  * [Session usage](../../../client-api/configuration/load-balance-and-failover.mdx#session-usage) 
</Admonition>
## ReadBalanceBehavior Options

  * `None`  
     * **Load-balance**  
       No load balancing will occur. The client will always select the _preferred node_.  
     * **Failover**  
       The client will failover nodes in the order they appear in the _topology nodes list_.  
      
         <Admonition type="note" title=""> 
         The list can be reordered, see 
         [Database Group Actions](../../../studio/database/settings/manage-database-group.mdx#database-group-topology---actions).  
         </Admonition>

  * `RoundRobin`  
    * **Load-balance**  
      For each _Read_ request, the client will address the next 
      node from the _topology nodes list_.  
    * **Failover**  
      In case of a failure, the client will try the next node in the round robin order. 

  * `FastestNode`  
    * **Load-balance**: _Read_ request will go to the fastest node.  
      The fastest node is determined by a [Speed Test](../../../client-api/cluster/speed-test.mdx).  
    * **Failover**  
      In case of a failure, a speed test will be triggered again and in the meantime the 
      client will use the _preferred node_.  
#### Example

<TabItem value="ReadBalanceBehavior" label="ReadBalanceBehavior">
<CodeBlock language="csharp">
{`Conventions = new DocumentConventions
\{
    ReadBalanceBehavior = ReadBalanceBehavior.FastestNode
\}
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="LoadBalanceBehavior" id="loadbalancebehavior" href="#loadbalancebehavior">
The nodes topology used to handle client requests can be selected per-session, 
using the [LoadBalanceBehavior convention](../../../client-api/session/configuration/use-session-context-for-load-balancing.mdx).  
<TabItem value="LoadBalanceBehavior" label="LoadBalanceBehavior">
<CodeBlock language="csharp">
{`Conventions = new DocumentConventions
\{
    LoadBalanceBehavior = LoadBalanceBehavior.UseSessionContext
\}
`}
</CodeBlock>
</TabItem>
</Admonition>



## Preferred Node

* The preferred node is selected by simply going over the _topology nodes list_ and returning the first node that has not had any errors.  

* If all nodes are in a failure state then the _first_ node in the list is returned. The user would get an error or recover if the error was transient.  


## Session Usage

* When using `RoundRobin` or `FastestNode` it might happen that the next [session](../../../client-api/session/opening-a-session.mdx) you open will access a different node.  

* A short delay in replicating changes to all nodes in the cluster is acceptable in most cases.  
  If you need to ensure that the next request will be able to _immediately_ read what you just wrote, 
  you need to use [Write Assurance](../../../client-api/session/saving-changes.mdx#waiting-for-replication---write-assurance).  



