import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).
* In this article:
  * [Indexing single field for FTS](../../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../../indexes/querying/searching.mdx#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../../indexes/querying/searching.mdx#boosting-search-results)
  * [Searching with wildcards](../../../indexes/querying/searching.mdx#searching-with-wildcards)
      * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../../indexes/querying/searching.mdx#when-usingoror)
      * [When using a custom analyzer](../../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
      * [When using the Exact analyzer](../../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="js">
{`class Employees_ByNotes extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            employeeNotes: e.Notes
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'employeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        this.analyze("employeeNotes", "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Using the `search` method has the advantage of using any of its functionalities,  
  such as using wildcards, searching for multiple terms, etc.  

* Refer to [Full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the index
    .query({ indexName: "Employees/ByNotes" })
     // Call 'search':
     // pass the index field name that was configured for FTS and the term to search for.
    .search("employeeNotes", "French")
    .all();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(employeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="js">
{`class Employees_ByEmployeeData extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            // Multiple document-fields can be indexed
            // into the single index-field 'employeeData' 
            employeeData: [e.FirstName, e.LastName, e.Title, e.Notes]
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const employees = await session
     // Query the static-index
    .query({ indexName: "Employees/ByEmployeeData" })
    .openSubclause()
     // A logical OR is applied between the following two Search calls:
    .search("employeeData", "Manager")
     // A logical AND is applied between the following two terms: 
    .search("employeeData", "French Spanish", "AND")
    .closeSubclause()
    .all();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(employeeData, "Manager") or search(employeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method, 
  which is available when using **a C# LINQ string** that is assigned to the `map` property in the Node.js index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="index_6" label="index_6">
<CodeBlock language="js">
{`// Extend the index class from 'AbstractCsharpIndexCreationTask':
class Products_ByAllValues extends AbstractCsharpIndexCreationTask \{
    constructor () \{
        super();

        // Using a C# LINQ string:  
        this.map = \`docs.Products.Select(product => new \{
                        AllValues = this.AsJson(product).Select(x => x.Value)
                    \})\`;

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'AllValues'
        this.index("AllValues", "Search");

        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.

        // Set the search engine type to Lucene:
        this.searchEngineType = "Lucene";
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`const products = await session
    .query({ indexName: "Products/ByAllValues" })
    .search("AllValues", "tofu")
    .all();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(AllValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../../client-api/session/querying/text-search/boost-search-results.mdx).



## Searching with wildcards

* When making a full-text search with wildcards in the search terms,
  the presence of wildcards (`*`) in the terms sent to the search engine is determined by the transformations applied by the
  [analyzer](../../../indexes/using-analyzers.mdx) used in the index.

* Note the different behavior in the following cases, as described below:
  * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../../indexes/querying/searching.mdx#when-usingoror)
  * [When using a custom analyzer](../../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
  * [When using the Exact analyzer](../../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

* When using [Corax](../../../indexes/search-engine/corax.mdx) as the search engine,  
  this behavior will only apply to indexes that are newly created or have been reset.
<Admonition type="note" title="">

##### When using&nbsp;`RavenStandardAnalyzer`&nbsp;or`StandardAnalyzer`&nbsp;or&nbsp;`NGramAnalyzer`:
Usually, the same analyzer used to tokenize field content at **indexing time** is also used to process the terms provided in the **full-text search query**
before they are sent to the search engine to retrieve matching documents.

**However, in the following cases**:

* When making a [dynamic search query](../../../client-api/session/querying/text-search/full-text-search.mdx)
* or when querying a static index that uses the default [RavenStandardAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-search-analyzer)
* or when querying a static index that uses the [StandardAnalyzer](../../../indexes/using-analyzers.mdx#analyzers-that-remove-common-stop-words)
* or when querying a static index that uses the [NGramAnalyzer](../../../indexes/using-analyzers.mdx#analyzers-that-tokenize-according-to-the-defined-number-of-characters)

the queried terms in the _search_ method are processed with the [LowerCaseKeywordAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-analyzer)  
before being sent to the search engine.

This analyzer does Not remove the `*`, so the terms are sent with `*`, as provided in the search terms.  
For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByNotes_usingDefaultAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        // Define the index-fields 
        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Since no analyzer is explicitly set
        // then the default 'RavenStandardAnalyzer' will be used at indexing time.

        // However, when making a search query with wildcards,
        // the 'LowerCaseKeywordAnalyzer' will be used to process the search terms
        // prior to sending them to the search engine.
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingDefaultAnalyzer" })
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the search method:
    .search("employeeNotes", "*rench")
    .all();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "employeeNotes:*rench";

assert.ok(explanation.includes(expectedVal), 
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/usingDefaultAnalyzer"
where search(EmployeeNotes, "*rench")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using a custom analyzer:
* When setting a [custom analyzer](../../../indexes/using-analyzers.mdx#creating-custom-analyzers) in your index to tokenize field content,
  then when querying the index, the search terms in the query will be processed according to the custom analyzer's logic.

* The `*` will remain in the terms if the custom analyzer allows it.
  It is the userâ€™s responsibility to ensure that wildcards are not removed by the custom analyzer if they should be included in the query.

* Note:  
  An exception to the above is when the wildcard is used as a suffix in the search term (e.g. `Fren*`).  
  In this case the wildcard will be included in the query regardless of the analyzer's logic.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByNotes_usingCustomAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Set a custom analyzer for the index-field:
        this.analyze("employeeNotes", "RemoveWildcardsAnalyzer");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Custom_analyzer" label="Custom_analyzer">
<CodeBlock language="js">
{`// The custom analyzer:
// ====================

const removeWildcardsanalyzer = \`
    using System.IO;
    using Lucene.Net.Analysis; 
    using Lucene.Net.Analysis.Standard;
    namespace CustomAnalyzers
    {
        public class RemoveWildcardsAnalyzer : StandardAnalyzer
        {
            public RemoveWildcardsAnalyzer() : base(Lucene.Net.Util.Version.LUCENE_30)
            {
            }
    
            public override TokenStream TokenStream(string fieldName, System.IO.TextReader reader)
            {
                // Read input stream and remove wildcards (*)
                string text = reader.ReadToEnd();
                string processedText = RemoveWildcards(text);
                StringReader newReader = new StringReader(processedText);
                
                return base.TokenStream(fieldName, newReader);
            }
    
            private string RemoveWildcards(string input)
            {
                // Replace wildcard characters with an empty string
                return input.Replace("*", "");
            }
        }
    }\`;

// Deploying the custom analyzer:
// ==============================

const analyzerDefinition = {
    name: "RemoveWildcardsAnalyzer",
    code: RemoveWildcardsAnalyzer
};

await documentStore.maintenance.send(new PutAnalyzersOperation(analyzerDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingCustomAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with wildcards to the Search method:
    .search("employeeNotes", "*French*")
    .all();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
const explanation = explanations.explanations[employees[0].id][0];

const expectedVal = "employeeNotes:french";
assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);

const notExpectedVal = "employeeNotes:*french";
assert.ok(!explanation.includes(notExpectedVal),
    \`'$\{explanation\}' does not contain '$\{notExpectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/UsingCustomAnalyzer"
where search(EmployeeNotes, "*French*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using the Exact analyzer:
When using the default Exact analyzer in your index (which is [KeywordAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-exact-analyzer)),  
then when querying the index, the wildcards in your search terms remain untouched.  
The terms are sent to the search engine exactly as produced by the analyzer.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="js">
{`class Employees_ByFirstName_usingExactAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            firstName: e.FirstName
        }));

        // Set the Exact analyzer for the index-field:
        // (The field will not be tokenized)
        this.index("firstName", "Exact");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="js">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByFirstName/usingExactAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the Search method:
    .search("firstName", "Mich*")
    .all();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "firstName:Mich*";

assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstName/usingExactAnalyzer"
where search(FirstName, "Mich*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



