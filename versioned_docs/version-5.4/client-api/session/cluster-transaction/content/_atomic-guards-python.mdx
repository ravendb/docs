import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* **Atomic Guards** are [compare-exchange key/value items](../../../../client-api/operations/compare-exchange/overview.mdx)
  that RavenDB creates and manages **automatically** to guarantee
  [ACID](../../../../server/clustering/cluster-transactions.mdx#cluster-transaction-properties) transactions in cluster-wide sessions.

* Each document is associated with its own unique atomic guard item.  
  Atomic guards coordinate between sessions that attempt to write to the same document concurrently.  
  Saving a document will be prevented if another session has modified the document.

* In this article:
  * [Atomic guard creation and update](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#atomic-guard-creation-and-update)
  * [Atomic guard usage example](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#atomic-guard-usage-example)
  * [Atomic guard database scope](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#atomic-guard-database-scope)
  * [Disabling atomic guards](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#disabling-atomic-guards)  
  * [When are atomic guards removed](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#when-are-atomic-guards-removed)
  * [Best practice when storing a document in a cluster-wide transaction](../../../../client-api/session/cluster-transaction/atomic-guards.mdx#best-practice-when-storing-a-document-in-a-cluster-wide-transaction)

</Admonition>
## Atomic guard creation and update

<Admonition type="info" title="">
Atomic guards are created and managed **only when the session's transaction mode is set to [CLUSTER_WIDE](../../../../client-api/session/cluster-transaction/overview.mdx#open-a-cluster-transaction)**.
</Admonition>
* **When creating a new document**:  
  A new atomic guard is created when a new document is successfully saved.

* **When modifying an existing document that already has an atomic guard**:
    * The atomic guard’s Raft index is incremented when the document is successfully saved after being modified.  
      This allows RavenDB to detect that the document has changed.
    * If another session had loaded the document before the document's version changed, it will not be able to save its changes
      unless it first reloads the updated version. Otherwise, a `ConcurrencyException` is thrown.

* **When modifying an existing document that doesn't have an atomic guard**:
    * A new atomic guard is created when modifying an existing document that does not yet have one.
    * The absence of the atomic guard may be because the document was created in a single-node session,  
      or because its atomic guard was manually removed (which is not recommended).

* **When saving a document fails**:
    * If a session's `save_changes()` fails, the entire session is rolled back and the atomic guard is Not created.
    * Ensure your business logic is designed to re-execute the session in case saving changes fails for any reason.



## Atomic guard usage example

In the code sample below, an atomic guard is automatically created when a new document is saved.  
It is then used to detect and prevent conflicting writes: when two sessions load and modify the same document,  
only the first save succeeds, and the second fails with a _ConcurrencyException_.

<TabItem value="atomic_guards_enabled" label="atomic_guards_enabled">
<CodeBlock language="python">
{`with store.open_session(
    # Open a cluster-wide session:
    session_options=SessionOptions(transaction_mode=TransactionMode.CLUSTER_WIDE)
) as session:
    session.store(User(), "users/johndoe")
    session.save_changes()
    # An atomic-guard is now automatically created for the new document "users/johndoe"

# Open two concurrent cluster-wide sessions:
with store.open_session(
    session_options=SessionOptions(transaction_mode=TransactionMode.CLUSTER_WIDE)
) as session1:
    with store.open_session(
        session_options=SessionOptions(transaction_mode=TransactionMode.CLUSTER_WIDE)
    ) as session2:
        # Both sessions load the same document:
        loaded_user_1 = session1.load("users/johndoe", User)
        loaded_user_1.name = "jindoe"
        loaded_user_2 = session2.load("users/johndoe", User)
        loaded_user_2.name = "jandoe"

        # session1 saves its changes first —
        # this increments the Raft index of the associated atomic guard.
        session1.save_changes()

        # session2 tries to save using an outdated atomic guard version
        # and fails with a ConcurrencyException.
        session2.save_changes()
`}
</CodeBlock>
</TabItem>
After running the above example, you can view the automatically created atomic guard in the Studio’s  
[Compare-Exchange view](../../../../studio/database/documents/compare-exchange-view.mdx#the-compare-exchange-view):

![Atomic Guard](../assets/atomic-guard.png)

1. These are **custom compare-exchange items** that were manually created by you,  
   e.g., via the [Put compare exchange operation](../../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx) - for any purpose you needed.  
   They are NOT the automatically created atomic guards.

2. This is the **atomic guard** that was generated by running the example above.

      The generated atomic guard **key** is: `rvn-atomic/users/johndoe`.  
      It is composed of:
       * The prefix `rvn-atomic/`.
       * The ID of the associated document.

      <Admonition type="warning" title="">
       * Although this Studio view allows editing compare-exchange items, **do not delete or modify atomic guard entries**.
       * Doing so will interfere with RavenDB's ability to track document versioning through atomic guards.
      </Admonition>



## Atomic guard database scope

* Atomic guards are local to the database on which they were defined.

* Since atomic guards are implemented as compare-exchange items,  
  they are Not externally replicated to other databases by any ongoing replication task.  
  Learn more in [why compare-exchange items are not replicated](../../../../client-api/operations/compare-exchange/overview.mdx#why-compare-exchange-items-are-not-replicated-to-external-databases).



## Disabling atomic guards

* Before atomic guards were introduced (in RavenDB 5.2), client code had to explicitly manage compare-exchange entries
  to ensure concurrency control and maintain ACID guarantees in cluster-wide transactions.

* You can still take this manual approach by disabling the automatic use of atomic guards in a cluster-wide session,
  and managing the required [compare-exchange key/value pairs](../../../../client-api/operations/compare-exchange/overview.mdx) yourself,
  as shown in this [example](../../../../client-api/operations/compare-exchange/overview.mdx#example-i---email-address-reservation).

* To disable the automatic creation and use of atomic guards in a cluster-wide session,
  set the session's `DisableAtomicDocumentWritesInClusterWideTransaction` configuration option to `true`.

<TabItem value="atomic_guards_disabled" label="atomic_guards_disabled">
<CodeBlock language="python">
{`with store.open_session(
    # Open a cluster-wide session
    session_options=SessionOptions(
        transaction_mode=TransactionMode.CLUSTER_WIDE,
        disable_atomic_document_writes_in_cluster_wide_transaction=True,
    )
) as session:
    session.store(User(), "users/johndoe")

    # No atomic-guard will be created upon save_changes
    session.save_changes()
`}
</CodeBlock>
</TabItem>



## When are atomic guards removed

Atomic guards are removed **automatically** in the following scenarios:  
(you don't need to clean them up manually)

* **Document deleted via a cluster-wide session**:
    * Create a document using a cluster wide session (an associated atomic guard is created).
    * Delete the document using a cluster wide session - its atomic guard will be removed automatically.

* **Document expires via the expiration feature**:
    * Create a document using a cluster wide session (an associated atomic guard is created).
    * Add the `@expires` metadata property the document, as described in [Document expiration](../../../../studio/database/settings/document-expiration.mdx).
    * When the expiration time is reached, the document and its atomic guard will both be removed automatically.
    * Since different cleanup tasks handle the removal of **expired** documents and the removal of their associated atomic guards,
      it may happen that atomic guards of removed documents would linger in the compare exchange entries list a short while longer before they are removed.
      You do Not need to remove such atomic guards yourself, they will be removed by the cleanup task.
<Admonition type="warning" title="">

* **Do not delete or modify atomic guards manually while they are in use by an active session**.  
  If a session attempts to save a document whose atomic guard has been removed or changed,  
  it will fail with an error.

* If you accidentally remove an atomic guard that is associated with an existing document,  
  you can restore it by re-saving the document in a cluster-wide session,  
  this will re-create the atomic guard automatically.

</Admonition>


## Best practice when storing a document in a cluster-wide transaction

* When working with a cluster-wide session,  
  we recommend that you always **`load` the document into the session before storing it** -  
  even if the document is expected to be a new document.

* This is especially important if a document (originally created in a cluster-wide transaction) was deleted **outside** of a cluster-wide session -
  e.g., when using a [single-node session](../../../../client-api/session/cluster-transaction/overview.mdx#cluster-wide-transaction-vs-single-node-transaction)
  or the [DeleteByQueryOperation](../../../../client-api/operations/common/delete-by-query.mdx).  
  In these cases, the document is deleted, but the atomic guard remains (it is not automatically removed).  
  If you attempt to re-create such a document without loading it first,
  RavenDB will fail to save it because the session is unaware of the existing atomic guard’s latest Raft index.

----

In this example, the document is loaded into the session BEFORE creating or modifying it:

<TabItem value="load_before_storing" label="load_before_storing">
<CodeBlock language="python">
{`with store.open_session(
    session_options=SessionOptions(
        # Open a cluster-wide session
        transaction_mode=TransactionMode.CLUSTER_WIDE
    )
) as session:
    # Load the user document BEFORE creating or updating
    user = session.load("users/johndoe", User)
        
    if user is None:
        # Document doesn't exist => create a new document
        new_user = User()
        new_user.name = "John Doe"
        # ... initialize other properties
        
        # Store the new user document in the session
        session.store(new_user, "users/johndoe")
    else:
        # Document exists => apply your modifications
        user.name = "New name"
        # ... make any other updates
        
        # No need to call store() again
        # RavenDB tracks changes on loaded entities
        
    # Commit your changes
    session.save_changes()
`}
</CodeBlock>
</TabItem>

<Admonition type="note" title="">

When _loading_ a document in a cluster-wide session, RavenDB attempts to retrieve the document from the document store:

* **If the document is found**, it is loaded into the session,
  and modifications will be saved successfully as long as no other session has modified the document in the meantime.
  Specifically, if the document’s [change vector](../../../../server/clustering/replication/change-vector.mdx) matches the one currently stored on the server,
  the save will proceed - after which the Raft index of the associated atomic guard will be incremented as expected.  
  Otherwise, RavenDB will fail the operation with a _ConcurrencyException_.

* **If no document is found**, RavenDB will check whether a matching atomic guard exists (as in the case when the document was deleted outside of a cluster-wide session):
    * **If an atomic guard exists**,
      the client constructs a change vector for the document using the atomic guard’s Raft index, and the document will be saved with this change vector.
    * **If no atomic guard exists**,
      the document is treated as a brand new document and will be saved as usual.

</Admonition>



