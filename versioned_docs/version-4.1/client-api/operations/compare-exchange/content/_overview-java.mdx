import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* The **Compare Exchange** feature allows you to perform cluster-wide _interlocked_ distributed operations.  

* Unique **Keys** can be reserved in the [Database Group](../../../../studio/database/settings/manage-database-group.mdx) accross the cluster.  
  Each key has an associated **Value**.  

* Modifying these values is an ***interlocked compare exchange*** operation.  

* Once defined, the Compare Exchange Values can be accessed via [GetCompareExchangeValuesOperation](../../../../client-api/operations/compare-exchange/get-compare-exchange-values.mdx),  
  or by using RQL in a query (see example-I below)  

* In this page:  
  * [Compare Exchange Transaction Scope](../../../../client-api/operations/compare-exchange/overview.mdx#compare-exchange-transaction-scope)  
  * [Creating a Key](../../../../client-api/operations/compare-exchange/overview.mdx#creating-a-key)  
  * [Updating a Key](../../../../client-api/operations/compare-exchange/overview.mdx#updating-a-key)  
  * [Example I - Email Address Reservation](../../../../client-api/operations/compare-exchange/overview.mdx#example-i---email-address-reservation)  
  * [Example II- Reserve a Shared Resource](../../../../client-api/operations/compare-exchange/overview.mdx#example-ii---reserve-a-shared-resource)  
</Admonition>
## Compare Exchange Transaction Scope

* Since the compare-exchange operations guarantee atomicity across the entire cluster, 
  the feature is **not** using the transaction associated with a session object, as a session transaction spans only a single node.  

* So if a compare-exchange operation has failed when used inside a session block, it will **not** be rolled back automatically upon a session transaction failure.  


## Creating a Key

* Provide the following when saving a **key**:

| Parameter | Description |
| ------------- | ---- |
| **Key** | A string under which _Value_ is saved, unique in the database scope across the cluster. This string can be up to 512 bytes. |
| **Value** | The Value that is associated with the _Key_. 
Can be a number, string, boolean, array or any JSON formatted object. |
| **Index** | The _Index_ number is indicating the version of _Value_.
The _Index_ is used for the concurrency control, similar to documents Etags. |

* When creating a _new_ 'Compare Exchange Key', the index should be set to `0`.  

* The [Put](../../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx) operation will succeed only if this key doesn't exist yet.  

* Note: Two different keys _can_ have the same values as long as the keys are unique.  


## Updating a Key

* Updating a 'Compare Exchange' key can be divided into 2 phases:

  1. [Get](../../../../client-api/operations/compare-exchange/get-compare-exchange-value.mdx) the existing _Key_. The associated _Value_ and _Index_ are received.  

  2. The _Index_ obtained from the read operation is provided to the [Put](../../../../client-api/operations/compare-exchange/put-compare-exchange-value.mdx) operation along with the new _Value_ to be saved.  
     This save will succeed only if the index that is provided to the 'Put' operation is the **same** as the index that was received from the server in the previous 'Get', 
     which means that the _Value_ was not modified by someone else between the read and write operations.


## Example I - Email Address Reservation  

* Compare Exchange can be used to maintain uniqueness across users emails accounts.  

* First try to reserve a new user email.  
  If the email is successfully reserved then save the user account document.  

<TabItem value="email" label="email">
<CodeBlock language="java">
{`String email = "user@example.com";

User user = new User();
user.setEmail(email);

try (IDocumentSession session = store.openSession()) \{
    session.store(user);

    // At this point, the user document has an Id assigned

    // Try to reserve a new user email
    // Note: This operation takes place outside of the session transaction,
    //       It is a cluster-wide reservation
    CompareExchangeResult<String> cmpXchgResult = store
        .operations().send(
            new PutCompareExchangeValueOperation<>(
                "emails/" + email, user.getId(), 0));

    if (!cmpXchgResult.isSuccessful()) \{
        throw new RuntimeException("Email is already in use");
    \}

    // At this point we managed to reserve/save the user email -
    // The document can be saved in SaveChanges
    session.saveChanges();
\}
`}
</CodeBlock>
</TabItem>  

**Implications**:

* The `User` object is saved as a document, hence it can be indexed, queried, etc.  

* If `session.saveChanges` fails, the email reservation is _not_ rolled back automatically. It is your responsibility to do so.  

* The compare exchange value that was saved can be accessed from `RQL` in a query:  

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="java">
{`try (IDocumentSession session = store.openSession()) {
    List<User> query = session.advanced().rawQuery(User.class,
        "from Users as s where id() == cmpxchg(\\"emails/ayende@ayende.com\\")")
        .toList();

    IDocumentQuery<User> q = session.advanced()
        .documentQuery(User.class)
        .whereEquals("id", CmpXchg.value("emails/ayende@ayende.com"));
}
`}
</CodeBlock>
</TabItem>  
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users as s where id() == cmpxchg("emails/ayende@ayende.com")
`}
</CodeBlock>
</TabItem>
</Tabs>


## Example II - Reserve a Shared Resource  

* Use compare exchange for a shared resource reservation.  

* The code also checks for clients who never release resources (i.e. due to failure) by using timeout.  

<TabItem value="shared_resource" label="shared_resource">
<CodeBlock language="java">
{`private class SharedResource \{
    private LocalDateTime reservedUntil;

    public LocalDateTime getReservedUntil() \{
        return reservedUntil;
    \}

    public void setReservedUntil(LocalDateTime reservedUntil) \{
        this.reservedUntil = reservedUntil;
    \}
\}

public void printWork() throws InterruptedException \{
    // Try to get hold of the printer resource
    long reservationIndex = lockResource(store, "Printer/First-Floor", Duration.ofMinutes(20));

    try \{
        // Do some work for the duration that was set.
        // Don't exceed the duration, otherwise resource is available for someone else.
    \} finally \{
        releaseResource(store, "Printer/First-Floor", reservationIndex);
    \}
\}

public long lockResource(IDocumentStore store, String resourceName, Duration duration) throws InterruptedException \{
    while (true) \{
        LocalDateTime now = LocalDateTime.now();

        SharedResource resource = new SharedResource();
        resource.setReservedUntil(now.plus(duration));

        CompareExchangeResult<SharedResource> saveResult =
            store.operations().send(
                new PutCompareExchangeValueOperation<SharedResource>(resourceName, resource, 0));

        if (saveResult.isSuccessful()) \{
            // resourceName wasn't present - we managed to reserve
            return saveResult.getIndex();
        \}

        // At this point, Put operation failed - someone else owns the lock or lock time expired
        if (saveResult.getValue().reservedUntil.isBefore(now)) \{
            // Time expired - Update the existing key with the new value
            CompareExchangeResult<SharedResource> takeLockWithTimeoutResult =
                store.operations().send(
                    new PutCompareExchangeValueOperation<>(resourceName, resource, saveResult.getIndex()));

            if (takeLockWithTimeoutResult.isSuccessful()) \{
                return takeLockWithTimeoutResult.getIndex();
            \}
        \}

        // Wait a little bit and retry
        Thread.sleep(20);
    \}
\}

public void releaseResource(IDocumentStore store, String resourceName, long index) \{
    CompareExchangeResult<SharedResource> deleteResult = store
        .operations().send(
            new DeleteCompareExchangeValueOperation<>(SharedResource.class, resourceName, index));

    // We have 2 options here:
    // deleteResult.Successful is true - we managed to release resource
    // deleteResult.Successful is false - someone else took the lock due to timeout
\}
`}
</CodeBlock>
</TabItem>



