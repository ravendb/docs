import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">
   

* Patching time series data (Append or Delete entries) can be performed via [Operations](../../../../../client-api/operations/what-are-operations.mdx).
  * Use [PatchOperation](../../../../../client-api/operations/patching/single-document.mdx) to patch data on a **single** document.
  * Use [PatchByQueryOperation](../../../../../client-api/operations/patching/set-based.mdx) to patch data on **multiple** documents.

* Patching time series entries on a single document can also be performed via the [Session](../../../../../document-extensions/timeseries/client-api/session/patch.mdx).

* In this page:  
  * [Patch time series data - single document](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#patch-time-series-data---single-document)
     * [Usage](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#usage)
     * [Examples](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#examples)
     * [Syntax](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#syntax)
  * [Patch time series data - multiple documents](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#patch-time-series-data---multiple-documents)
     * [Usage](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#usage-1)
     * [Examples](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#examples-1)
     * [Syntax](../../../../../document-extensions/timeseries/client-api/operations/patch.mdx#syntax-1)

</Admonition>
## Patch time series data - single document
### Usage

* Create a `PatchRequest` instance:
    * Define the Append or Delete action using the [JavaScript time series API](../../../../../document-extensions/timeseries/client-api/javascript-support.mdx).

* Create a `PatchOperation` instance and pass it:
   * The ID of the document to patch
   * The document change vector (or `null`)
   * The `PatchRequest` object

* Execute the `PatchOperation` operation by calling `store.Operations.Send`

* NOTE:  
  * The server treats timestamps passed in the patch request script as **UTC**, no conversion is applied by the client to local time.
  * Appending entries to a time series that doesn't yet exist yet will create the time series.
  * No exception is thrown if the specified document does not exist.
### Examples

* In this example, we **append** a single entry to time series "HeartRates" on the specified document.
<TabItem value="TS_region-Operation_Patch-Append-Single-TS-Entry" label="TS_region-Operation_Patch-Append-Single-TS-Entry">
<CodeBlock language="csharp">
{`var baseTime = DateTime.UtcNow;

var patchRequest = new PatchRequest
\{
    // Define the patch request using JavaScript:
    Script = "timeseries(this, $timeseries).append($timestamp, $values, $tag);",
    
    // Provide values for the parameters in the script:
    Values =
    \{
        \{ "timeseries", "HeartRates" \},
        \{ "timestamp", baseTime.AddMinutes(1) \},
        \{ "values", 59d \},
        \{ "tag", "watches/fitbit" \}
    \}
\};

// Define the patch operation;
var patchOp = new PatchOperation("users/john", null, patchRequest);

// Execute the operation:
store.Operations.Send(patchOp);
`}
</CodeBlock>
</TabItem>

* In this example, we **append** 100 entries to time series "HeartRates" on the specified document.  
  Timestamps and values are drawn from an array and other arguments are provided in the "Values" property.  
<TabItem value="TS_region-Operation_Patch-Append-100-TS-Entries" label="TS_region-Operation_Patch-Append-100-TS-Entries">
<CodeBlock language="csharp">
{`var baseTime = DateTime.UtcNow;

// Create arrays of timestamps and random values to patch
var values = new List<double>();
var timeStamps = new List<DateTime>();

for (var i = 0; i < 100; i++)
\{
    values.Add(68 + Math.Round(19 * new Random().NextDouble()));
    timeStamps.Add(baseTime.AddMinutes(i));
\}

var patchRequest = new PatchRequest
\{
    Script = @"var i = 0;
               for (i = 0; i < $values.length; i++) \{
                   timeseries(id(this), $timeseries).append (
                       $timeStamps[i],
                       $values[i],
                       $tag);
               \}",
    Values =
    \{
        \{ "timeseries", "HeartRates" \},
        \{ "timeStamps", timeStamps \},
        \{ "values", values \},
        \{ "tag", "watches/fitbit" \}
    \}
\};

var patchOp = new PatchOperation("users/john", null, patchRequest);
store.Operations.Send(patchOp);
`}
</CodeBlock>
</TabItem>  

* In this example, we **delete** a range of 50 entries from time series "HeartRates" on the specified document.  
<TabItem value="TS_region-Operation_Patch-Delete-50-TS-Entries" label="TS_region-Operation_Patch-Delete-50-TS-Entries">
<CodeBlock language="csharp">
{`store.Operations.Send(new PatchOperation("users/john", null,
    new PatchRequest
    \{
        Script = "timeseries(this, $timeseries).delete($from, $to);",
        Values =
        \{
            \{ "timeseries", "HeartRates" \},
            \{ "from", baseTime \},
            \{ "to", baseTime.AddMinutes(49) \}
        \}
    \}));
`}
</CodeBlock>
</TabItem>  
### Syntax

* The detailed syntax of `PatchOperation` is listed under this [syntax section](../../../../../client-api/operations/patching/single-document.mdx#operations-api).

* The detailed syntax of `PatchRequest` is listed under this [syntax section](../../../../../client-api/operations/patching/single-document.mdx#patchrequest).

* The available JavaScript API methods are detailed in the [time series JavaScript support](../../../../../document-extensions/timeseries/client-api/javascript-support.mdx) article.



## Patch time series data - multiple documents
### Usage

* In order to patch time series data on multiple documents, you need to:
  * Define a query that retrieves the set of documents to be patched (can be a dynamic or an index query).
  * Define the patching action that will be executed on the matching documents.

* This is achieved by defining a string, or creating an instance of `IndexQuery` that contains such string,  
  with the following two parts:
  * **The query**: provide an [RQL](../../../../../querying/rql/what-is-rql.mdx) code snippet to filter the documents you want to patch.
  * **The patching script**: use the [JavaScript time series API](../../../../../document-extensions/timeseries/client-api/javascript-support.mdx) to define the patching action.
    
* Create a `PatchByQueryOperation` instance and pass it the `IndexQuery` object, or the defined string.

* Execute the `PatchByQueryOperation` by calling `store.Operations.Send`.  
  * The patch operation will be executed only on documents that match the query. 
  * This type of operation can be awaited for completion. Learn more in [Manage length operations](../../../../../client-api/operations/what-are-operations.mdx#manage-lengthy-operations).

* NOTE:
    * The server treats timestamps passed in the patch request script as **UTC**, no conversion is applied.
    * No exception is thrown if any of the documents no longer exist during patching.
### Examples

* In this example, we **append** an entry to time series "HeartRates" on ALL documents in the "Users" collection.
<TabItem value="TS_region-PatchByQueryOperation-Append-To-Multiple-Docs" label="TS_region-PatchByQueryOperation-Append-To-Multiple-Docs">
<CodeBlock language="csharp">
{`var indexQuery = new IndexQuery
\{
    // Define the query and the patching action that follows the 'update' keyword:
    Query = @"from Users as u
              update
              \{
                  timeseries(u, $name).append($time, $values, $tag)
              \}",
    
    // Provide values for the parameters in the script:
    QueryParameters = new Parameters
    \{
        \{ "name", "HeartRates" \},
        \{ "time", baseline.AddMinutes(1) \},
        \{ "values", new[] \{59d\} \},
        \{ "tag", "watches/fitbit" \}
    \}
\};

// Define the patch operation:
var patchByQueryOp = new PatchByQueryOperation(indexQuery);

// Execute the operation:
store.Operations.Send(patchByQueryOp);
`}
</CodeBlock>
</TabItem>

* In this example, we **delete** the "HeartRates" time series from documents that match the query criteria.  
<TabItem value="TS_region-PatchByQueryOperation-Delete-From-Multiple-Docs" label="TS_region-PatchByQueryOperation-Delete-From-Multiple-Docs">
<CodeBlock language="csharp">
{`PatchByQueryOperation deleteByQueryOp = new PatchByQueryOperation(new IndexQuery
\{
    Query = @"from Users as u
              where u.Age < 30
              update
              \{
                  timeseries(u, $name).delete($from, $to)
              \}",
    
    QueryParameters = new Parameters
    \{
        \{ "name", "HeartRates" \},
        \{ "from", DateTime.MinValue \},
        \{ "to", DateTime.MaxValue \}
    \}
\});

// Execute the operation: 
// Time series "HeartRates" will be deleted for all users with age < 30
store.Operations.Send(deleteByQueryOp);
`}
</CodeBlock>
</TabItem>  

* In this example, for each document in the "Users" collection, we patch a document field with data retrieved from its time series entries.
  The document's time series data itself is Not patched.
  The document `NumberOfUniqueTagsInTS` field will be updated with the number of unique tags in the user's "HeartRates" time series.
  To do this, we use the JavaScript [get](../../../../../document-extensions/timeseries/client-api/javascript-support.mdx#section-3) method to get all the time series entries for each document  
  and extract each entry's tag.  
<TabItem value="TS_region-PatchByQueryOperation-Get" label="TS_region-PatchByQueryOperation-Get">
<CodeBlock language="csharp">
{`PatchByQueryOperation patchNumOfUniqueTags = new PatchByQueryOperation(new IndexQuery
\{
    Query = @"
        declare function patchDocumentField(doc) \{
            var differentTags = [];
            var entries = timeseries(doc, $name).get($from, $to);

            for (var i = 0; i < entries.length; i++) \{
                var e = entries[i];

                if (e.Tag !== null) \{
                    if (!differentTags.includes(e.Tag)) \{
                        differentTags.push(e.Tag);
                    \}
                \}
            \}

            doc.NumberOfUniqueTagsInTS = differentTags.length;
            return doc;
        \}

        from Users as u
        update \{
            put(id(u), patchDocumentField(u))
        \}",

    QueryParameters = new Parameters
    \{
        \{ "name", "HeartRates" \},
        \{ "from", DateTime.MinValue \},
        \{ "to", DateTime.MaxValue \}
    \}
\});

// Execute the operation and Wait for completion:
var result = store.Operations.Send(patchNumOfUniqueTags).WaitForCompletion();
`}
</CodeBlock>
</TabItem>  
### Syntax

* The detailed syntax of `PatchByQueryOperation` is listed under this [syntax section](../../../../../client-api/operations/patching/set-based.mdx#syntax-overview).

* The available JavaScript API methods are detailed in the [time series JavaScript support](../../../../../document-extensions/timeseries/client-api/javascript-support.mdx) article.




