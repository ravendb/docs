import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* This article explains how to perform a **vector search** using a **static index**.  
  **Prior to this article**, it is recommended to get familiar with the [Vector search using a dynamic query](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx) article.

* A static index allows you to define a **vector index-field**, enabling you to execute vector searches
  while leveraging the advantages of RavenDB's [indexes](../../../indexes/what-are-indexes.mdx).

* The vector search feature is only supported by indexes that use the [Corax search engine](../../../indexes/search-engine/corax.mdx).

* In this article:
    * [Indexing a vector field - Overview](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-a-vector-field---overview)
       * [Defining a vector field in a static index](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#defining-a-vector-field-in-a-static-index)
       * [Parameters defined at index definition](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#parameters-defined-at-index-definition)
       * [Behavior during indexing](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#behavior-during-indexing)
       * [Parameters used at query time](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#parameters-used-at-query-time)
       * [Behavior when documents are deleted](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#vector-behavior-when-documents-are-deleted)
    * [Indexing vector data - TEXT](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---text)
      * [Indexing raw text](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-raw-text)
      * [Indexing pre-made text-embeddings](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings)
    * [Indexing vector data - NUMERICAL](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---numerical)
      * [Indexing numerical data and querying using numeric input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-numeric-input)
      * [Indexing numerical data and querying using text input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-text-input)
    * [Indexing multiple field types](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-multiple-field-types)
    * [Querying the static index for similar documents](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#querying-the-static-index-for-similar-documents)
    * [Configure the vector field in the Studio](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#configure-the-vector-field-in-the-studio)

</Admonition>

## Indexing a vector field - Overview

<Admonition type="note" title="">

#### Defining a vector field in a static index

To define a vector index-field in your static-index definition:  

* **From the Client API**:  
 
    **`LoadVector()`**:  
    When indexing **pre-made text-embeddings** generated by RavenDB's [Embeddings generation tasks](../../../ai-integration/generating-embeddings/overview.mdx),  
    use the `LoadVector()` method in your index definition.  
    An example is available in [Indexing pre-made text-embeddings](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings).
   
    **`CreateVector()`**:  
    When indexing **your own data** (textual or numerical) that was not generated by these tasks,  
    use the `CreateVector()` method in your index definition.  
    An example is available in [Indexing raw text](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-raw-text).  

* **From the Studio**:  
  See [Define a vector field in the Studio](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#define-a-vector-field-in-the-studio).  

The **source data types** that can be used for vector search are detailed in [Data types for vector search](../../../ai-integration/vector-search/data-types-for-vector-search.mdx).

</Admonition>

<Admonition type="note" title="">

#### Parameters defined at index definition  

The following params can be defined for the vector index-field in the index definition:  

**Source embedding type** -   
RavenDB supports performing vector search on TEXTUAL values or NUMERICAL arrays.  
This param specifies the embedding format of the source data to be indexed.  
Options include `Text`, `Single`, `Int8`, or `Binary`.  

**Destination embedding type** -   
Specify the quantization format for the embeddings that will be generated.  
Read more about quantization in [Quantization options](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#quantization-options).

**Dimensions** -   
For numerical input only - define the size of the array from your source document.  

* If this param is Not provided -  
  the size will be determined by the first document indexed and will apply to all subsequent documents.

* Ensure the dimensionality of these numerical arrays (i.e., their length) is consistent across all source documents for the indexed field.
  An index error will occur if a source document has a different dimension for the indexed field.

**Number of edges** -  
Specify the number of edges that will be created for a vector during indexing.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfEdges](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofedges).

**Number of candidates for indexing time** -   
The  number of candidates (potential neighboring vectors) that RavenDB evaluates during vector indexing.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfCandidatesForIndexing](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofcandidatesforindexing).   
(Note, this param differs from the number of candidates for query time).

</Admonition>

<Admonition type="note" title="">

#### Behavior during indexing

* **Raw textual input**:  
  When indexing raw textual input from your documents, RavenDB generates embedding vectors using the built-in  
  [bge-micro-v2](https://huggingface.co/TaylorAI/bge-micro-v2) sentence-transformer model, which are then indexed.

* **Pre-made text-embeddings input**:  
  When indexing embeddings that are pre-generated from your documents' raw text by RavenDB's  
  [Embeddings generation tasks](../../../ai-integration/generating-embeddings/overview.mdx),
  RavenDB indexes them without additional transformation, unless quantization is applied.  
 
* **Raw numerical input**:  
  When indexing pre-made numerical arrays that are already in vector format but were Not generated by these tasks,  
  such as numerical arrays you created externally, RavenDB indexes them without additional transformation,  
  unless quantization is applied.  

The embeddings are indexed on the server using the [HNSW algorithm](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world).  
This algorithm organizes embeddings into a high-dimensional graph structure,  
enabling efficient retrieval of Approximate Nearest Neighbors (ANN) during queries.

</Admonition>

<Admonition type="note" title="">

#### Parameters used at query time

**Minimum similarity** -  
You can specify the minimum similarity to use when searching for related vectors. Can be a value between `0.0f` and `1.0f`.  
A value closer to `1.0f` requires higher similarity between vectors, while a value closer to `0.0f` allows for less similarity.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultMinimumSimilarity](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultminimumsimilarity).

**Number of candidates at query time** -  
You can specify the maximum number of vectors that RavenDB will return from a graph search.  
The number of the resulting documents that correspond to these vectors may be:  

  * lower than the number of candidates - when multiple vectors originated from the same document.  
   
  * higher than the number of candidates - when the same vector is shared between multiple documents.

If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfCandidatesForQuerying](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofcandidatesforquerying).

**Search method** -  
You can specify the search method at query time:  

  *  _Approximate Nearest-Neighbor search_ (Default):  
     Search for related vectors in an approximate manner, providing faster results.

  *  _Exact search_:  
     Perform a thorough scan of the vectors to find the actual closest vectors,  
     offering better accuracy but at a higher computational cost.

**To ensure consistent comparisons** -  
the search term is transformed into an embedding vector using the same method as the vector index-field.  

**Search results** -  
The server will search for the most similar vectors in the indexed vector space, taking into account all the parameters described.
The documents that correspond to the resulting vectors are then returned to the client.

By default, the resulting documents will be ordered by their score.
You can modify this behavior using the [Indexing.Corax.VectorSearch.OrderByScoreAutomatically](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchorderbyscoreautomatically) configuration key.  
In addition, you can apply any of the 'order by' methods to your query, as explained in [sort query results](../../../client-api/session/querying/sort-query-results.mdx).

</Admonition>

<Admonition type="note" title="">

#### Vector behavior when documents are deleted  

* RavenDB's implementation of the HNSW graph is append-only.  

* When all documents associated with a specific vector are deleted, the vector itself is Not physically removed but is soft-deleted.
  This means the vector is marked as deleted and will no longer appear in query results.  
  Currently, compaction is not supported.

</Admonition>

---

## Indexing vector data - TEXT

### Indexing raw text

The index in this example indexes data from raw text.  
For an index that indexes pre-made text-embeddings see [this example below](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings).
 
The following index defines a **vector field** named `VectorfromText`.  
It indexes embeddings generated from the raw textual data in the `Name` field of all _Product_ documents.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`public class Products_ByVector_Text :
    AbstractIndexCreationTask<Product, Products_ByVector_Text.IndexEntry>
{
    public class IndexEntry()
    {
        // This index-field will hold the embeddings that will be generated
        // from the TEXT in the documents
        public object VectorFromText { get; set; }
    }
    
    public Products_ByVector_Text()
    {
        Map = products => from product in products
            select new IndexEntry
            {
                // Call 'CreateVector' to create a VECTOR FIELD.
                // Pass the document field containing the text
                // from which the embeddings will be generated.
                VectorFromText = CreateVector(product.Name)
            };

        // You can customize the vector field using EITHER of the following syntaxes:
        // ==========================================================================
        
        // Customize using VectorOptions:
        VectorIndexes.Add(x => x.VectorFromText,
            new VectorOptions()
            {
                // Define the source embedding type
                SourceEmbeddingType = VectorEmbeddingType.Text, 
                
                // Define the quantization for the destination embedding
                DestinationEmbeddingType = VectorEmbeddingType.Single,
                
                // Optionally, set the number of edges 
                NumberOfEdges = 20,
                
                // Optionally, set the number of candidates
                NumberOfCandidatesForIndexing = 20
            });
        
        // OR - Customize using builder:
        Vector(x=>x.VectorFromText,
            builder => builder
                .SourceEmbedding(VectorEmbeddingType.Text)
                .DestinationEmbedding(VectorEmbeddingType.Single)
                .NumberOfEdges(20)
                .NumberOfCandidates(20));

        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JS_index" label="JS_index">
<CodeBlock language="csharp">
{`public class Products_ByVector_Text_JS : AbstractJavaScriptIndexCreationTask
{
    public Products_ByVector_Text_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Products', function (product) {
                   return {
                       VectorFromText: createVector(product.Name)
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("VectorFromText", new IndexFieldOptions()
        {
            Vector = new VectorOptions()
            {
                SourceEmbeddingType = VectorEmbeddingType.Text, 
                DestinationEmbeddingType = VectorEmbeddingType.Single,
                NumberOfEdges = 20,
                NumberOfCandidatesForIndexing = 20
            }
        });

        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
<CodeBlock language="csharp">
{`var indexDefinition = new IndexDefinition
{
    Name = "Products/ByVector/Text",
    
    Maps = new HashSet<string>
    {
        @"
          from product in docs.Products
          select new 
          {
              VectorFromText = CreateVector(product.Name)
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "VectorFromText",
            new IndexFieldOptions()
            {
                Vector = new VectorOptions()
                {
                    SourceEmbeddingType = VectorEmbeddingType.Text,
                    DestinationEmbeddingType = VectorEmbeddingType.Single,
                    NumberOfEdges = 20,
                    NumberOfCandidatesForIndexing = 20
                }
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Product_ documents where the `Name` field is similar to the search term `"italian food"`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var similarProducts = session
    .Query<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
     // Perform a vector search
     // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
             // Call 'WithField'
             // Specify the index-field in which to search for similar values
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
             // Call 'ByText'   
             // Provide the term for the similarity comparison
            .ByText("italian food"),
        // Optionally, specify the minimum similarity value
        minimumSimilarity: 0.82f,
        // Optionally, specify the number candidates for querying
        numberOfCandidates: 20,
        // Optionally, specify whether the vector search should use the 'exact search method'
        isExact: true)
     // Waiting for not-stale results is not mandatory
     // but will assure results are not stale
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var similarProducts = await asyncSession
    .Query<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
            .ByText("italian food"), 0.82f, 20, isExact: true)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var similarProducts = session.Advanced
    .DocumentQuery<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
            .ByText("italian food"), 0.82f, 20, isExact: true)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var similarProducts = await asyncSession.Advanced
    .AsyncDocumentQuery<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
            .ByText("italian food"),
        0.82f, 20, isExact: true)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var similarProducts = session.Advanced
    .RawQuery<Product>(@"
        from index 'Products/ByVector/Text'
        // Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
        where exact(vector.search(VectorFromText, $searchTerm, 0.82, 20))")
    .AddParameter("searchTerm", "italian food")
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var similarProducts = await asyncSession.Advanced
    .AsyncRawQuery<Product>(@"
        from index 'Products/ByVector/Text'
        // Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
        where exact(vector.search(VectorFromText, $searchTerm, 0.82, 20))")
    .AddParameter("searchTerm", "italian food")
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByVector/Text"
// Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
where exact(vector.search(VectorFromText, $searchTerm, 0.82, 20))
{ "searchTerm" : "italian food" }
`}
</CodeBlock>
</TabItem>
</Tabs>

### Indexing pre-made text-embeddings

The index in this example defines a **vector field** named `VectorFromTextEmbeddings`.  
It indexes pre-made text-embeddings that were generated by this
[embedding generation task](../../../ai-integration/generating-embeddings/embeddings-generation-task.mdx#configuring-an-embeddings-generation-task---from-the-studio).
 
<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`public class Categories_ByPreMadeTextEmbeddings :
    AbstractIndexCreationTask<Category, Categories_ByPreMadeTextEmbeddings.IndexEntry>
{
    public class IndexEntry()
    {
        // This index-field will hold the text embeddings
        // that were pre-made by the Embeddings Generation Task
        public object VectorFromTextEmbeddings { get; set; }
    }
    
    public Categories_ByPreMadeTextEmbeddings()
    {
        Map = categories => from category in categories
            select new IndexEntry
            {
                // Call 'LoadVector' to create a VECTOR FIELD. Pass:
                // * The document field name to be indexed (as a string) 
                // * The identifier of the task that generated the embeddings
                //   for the 'Name' field
                VectorFromTextEmbeddings = LoadVector("Name", "id-for-task-open-ai")
            };

        VectorIndexes.Add(x => x.VectorFromTextEmbeddings,
            new VectorOptions()
            {
               // Vector options can be customized
               // in the same way as the above index example.
            });
        
        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JS_index" label="JS_index">
<CodeBlock language="csharp">
{`public class Categories_ByPreMadeTextEmbeddings_JS : AbstractJavaScriptIndexCreationTask
{
    public Categories_ByPreMadeTextEmbeddings_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Categories', function (category) {
                   return {
                       VectorFromTextEmbeddings:
                           loadVector('Name', 'id-for-task-open-ai')
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("VectorFromTextEmbeddings", new IndexFieldOptions()
        {
            Vector = new VectorOptions()
            {
                // Vector options can be customized
                // in the same way as the above index example.
            }
        });

        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
<CodeBlock language="csharp">
{`var indexDefinition = new IndexDefinition
{
    Name = "Categories/ByPreMadeTextEmbeddings",
    Maps = new HashSet<string>
    {
        @"
          from category in docs.Categories
          select new 
          {
              VectorFromTextEmbeddings = LoadVector(""Name"", ""id-for-task-open-ai"")
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "VectorFromTextEmbeddings",
            new IndexFieldOptions()
            {
                Vector = new VectorOptions()
                {
                    // Vector options can be customized
                    // in the same way as the above index example.
                }
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Category_ documents where the `Name` field is similar to the search term `"candy"`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var similarCategories = session
    .Query<Categories_ByPreMadeTextEmbeddings.IndexEntry, Categories_ByPreMadeTextEmbeddings>()
    // Perform a vector search
    // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
            // Call 'WithField'
            // Specify the index-field in which to search for similar values
            .WithField(x => x.VectorFromTextEmbeddings),
        searchTerm => searchTerm
            // Call 'ByText'
            // Provide the search term for the similarity comparison
            .ByText("candy"),
        // Optionally, specify the minimum similarity value
        minimumSimilarity: 0.75f,
        // Optionally, specify the number of candidates for querying
        numberOfCandidates: 20,
        // Optionally, specify whether the vector search should use the 'exact search method'
        isExact: true)
    // Waiting for not-stale results is not mandatory
    // but will assure results are not stale
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Category>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var similarCategories = await asyncSession
    .Query<Categories_ByPreMadeTextEmbeddings.IndexEntry, Categories_ByPreMadeTextEmbeddings>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromTextEmbeddings),
        searchTerm => searchTerm
            .ByText("candy"), 0.75f, 20, isExact: true)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Category>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var similarCategories = session.Advanced
    .DocumentQuery<Categories_ByPreMadeTextEmbeddings.IndexEntry, Categories_ByPreMadeTextEmbeddings>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromTextEmbeddings),
        searchTerm => searchTerm
            .ByText("candy"), 0.75f, 20, isExact: true)
    .WaitForNonStaleResults()
    .OfType<Category>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var similarCategories = await asyncSession.Advanced
    .AsyncDocumentQuery<Categories_ByPreMadeTextEmbeddings.IndexEntry, Categories_ByPreMadeTextEmbeddings>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromTextEmbeddings),
        searchTerm => searchTerm
            .ByText("candy"),
        0.75f, 20, isExact: true)
    .WaitForNonStaleResults()
    .OfType<Category>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var similarCategories = session.Advanced
    .RawQuery<Category>(@"
        from index 'Categories/ByPreMadeTextEmbeddings'
        // Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
        where exact(vector.search(VectorFromTextEmbeddings, $searchTerm, 0.75, 20))")
    .AddParameter("searchTerm", "candy")
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var similarCategories = await asyncSession.Advanced
    .AsyncRawQuery<Category>(@"
        from index 'Categories/ByPreMadeTextEmbeddings'
        // Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
        where exact(vector.search(VectorFromTextEmbeddings, $searchTerm, 0.75, 20))")
    .AddParameter("searchTerm", "candy")
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Categories/ByPreMadeTextEmbeddings"
// Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
where exact(vector.search(VectorFromTextEmbeddings, $p0, 0.75, 20))
{ "p0": "candy" }
`}
</CodeBlock>
</TabItem>
</Tabs>

---

## Indexing vector data - NUMERICAL

<Admonition type="note" title="">

* RavenDB’s [Embedding generation tasks](../../../ai-integration/generating-embeddings/overview.mdx) are typically used to generate vector embeddings from TEXTUAL data stored in your documents. 
  These embeddings are then stored in [dedicated collections](../../../ai-integration/generating-embeddings/embedding-collections.mdx).

* However, you are not limited to using these built-in tasks.
  You can generate your own NUMERICAL embeddings - from any source (e.g., text, image, audio, etc.) - using a suitable multimodal model, and store them:
    * as numerical arrays in your documents’ properties, or
    * as attachments associated with your documents.

* This numerical data can be indexed in a vector field in a static-index.  
  Once indexed, you can query the vector field using either of the following:

  * **Query using a numerical embedding (direct vector)**:  
    You provide a numerical array as the search term, and RavenDB compares it directly against the indexed embeddings.
    See [Indexing numerical data and querying using numeric input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-numeric-input).  

  * **Query using a text input**:   
    You provide a text string as the search term and specify an existing [Embedding generation task](../../../ai-integration/generating-embeddings/overview.mdx) that will convert this text into a vector embedding.
    This will work only if:  
    * the vector field you're querying contains numerical embeddings that were created using the **same model** as the one configured in the specified task, and
    * that task exists in your database (i.e., its identifier is still available).

    In this case, RavenDB uses the task to transform the search term into an embedding, then compares it to the vector data that you had previously indexed yourself.
    To improve performance, the generated embedding is cached, so repeated queries with the same search term don’t require re-computation.
    
    This hybrid approach allows you to index custom embeddings (e.g., externally generated image vectors)
    while still benefiting from RavenDB’s ability to perform semantic text search, as long as the same model was used for both.  
    See [Indexing numerical data and querying using text input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-text-input).  

* <Admonition type="info" title="">
  The examples in this section use the [sample data provided in the dynamic query article](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#sample-data).
  </Admonition>

</Admonition>

### Indexing numerical data and querying using numeric input

The following index defines a vector field named `VectorFromSingle`.  
It indexes embeddings generated from the numerical data in the `TagsEmbeddedAsSingle` field of all _Movie_ documents.  
The raw numerical data in the source documents is in **32-bit floating-point format**.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`public class Movies_ByVector_Single :
    AbstractIndexCreationTask<Movie, Movies_ByVector_Single.IndexEntry>
{
    public class IndexEntry()
    {
        // This index-field will hold the embeddings that will be generated
        // from the NUMERICAL content in the documents.
        public object VectorFromSingle { get; set; }
    }
    
    public Movies_ByVector_Single()
    {
        Map = movies => from movie in movies
            select new IndexEntry
            {
                // Call 'CreateVector' to create a VECTOR FIELD.
                // Pass the document field containing the array (32-bit floating-point values)
                // from which the embeddings will be generated.
                VectorFromSingle = CreateVector(movie.TagsEmbeddedAsSingle)
            };

        // EITHER - Customize the vector field using VectorOptions:
        VectorIndexes.Add(x => x.VectorFromSingle,
            new VectorOptions()
            {
                // Define the source embedding type
                SourceEmbeddingType = VectorEmbeddingType.Single,
                
                // Define the quantization for the destination embedding
                DestinationEmbeddingType = VectorEmbeddingType.Single,
                
                // It is recommended to configure the number of dimensions
                // which is the size of the arrays that will be indexed.
                Dimensions = 2,
                
                // Optionally, set the number of edges and candidates
                NumberOfEdges = 20,
                NumberOfCandidatesForIndexing = 20
            });
        
        // OR - Customize the vector field using builder:
        Vector(x => x.VectorFromSingle,
            builder => builder
                .SourceEmbedding(VectorEmbeddingType.Single)
                .DestinationEmbedding(VectorEmbeddingType.Single)
                .Dimensions(2)
                .NumberOfEdges(20)
                .NumberOfCandidates(20));

        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JS_index" label="JS_index">
<CodeBlock language="csharp">
{`public class Movies_ByVector_Single_JS : AbstractJavaScriptIndexCreationTask
{
    public Movies_ByVector_Single_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Movies', function (movie) {
                   return {
                       VectorFromSingle: createVector(movie.TagsEmbeddedAsSingle)
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("VectorFromSingle", new IndexFieldOptions()
        {
            Vector = new VectorOptions()
            {
                SourceEmbeddingType = VectorEmbeddingType.Single, 
                DestinationEmbeddingType = VectorEmbeddingType.Single,
                Dimensions = 2,
                NumberOfEdges = 20,
                NumberOfCandidatesForIndexing = 20
            }
        });

        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
<CodeBlock language="csharp">
{`var indexDefinition = new IndexDefinition 
{
    Name = "Movies/ByVector/Single",

    Maps = new HashSet<string>
    {
        @"
          from movie in docs.Movies
          select new 
          {
              VectorFromSingle = CreateVector(movie.TagsEmbeddedAsSingle)
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "VectorFromSingle",
            new IndexFieldOptions()
            {
                Vector = new VectorOptions()
                {
                    SourceEmbeddingType = VectorEmbeddingType.Single,
                    DestinationEmbeddingType = VectorEmbeddingType.Single,
                    Dimensions = 2,
                    NumberOfEdges = 20,
                    NumberOfCandidatesForIndexing = 20
                }
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Execute a vector search using the index:  
(Provide a vector as the search term to the `ByEmbedding` method)

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var similarMovies = session
    .Query<Movies_ByVector_Single.IndexEntry, Movies_ByVector_Single>()
     // Perform a vector search
     // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
             // Call 'WithField'
             // Specify the index-field in which to search for similar values
            .WithField(x => x.VectorFromSingle),
        queryVector => queryVector
             // Call 'ByEmbedding'   
             // Provide the vector for the similarity comparison
            .ByEmbedding(
                 new RavenVector<float>(new float[] { 6.599999904632568f, 7.699999809265137f })))
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession
    .Query<Movies_ByVector_Single.IndexEntry, Movies_ByVector_Single>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromSingle),
        queryVector => queryVector
            .ByEmbedding(
                new RavenVector<float>(new float[] { 6.599999904632568f, 7.699999809265137f })))
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var similarMovies = session.Advanced
    .DocumentQuery<Movies_ByVector_Single.IndexEntry, Movies_ByVector_Single>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromSingle),
        queryVector => queryVector
            .ByEmbedding(
                new RavenVector<float>(new float[] { 6.599999904632568f, 7.699999809265137f })))
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession.Advanced
    .AsyncDocumentQuery<Movies_ByVector_Single.IndexEntry, Movies_ByVector_Single>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromSingle),
        queryVector => queryVector
            .ByEmbedding(
                new RavenVector<float>(new float[] { 6.599999904632568f, 7.699999809265137f })))
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var similarMovies = session.Advanced
    .RawQuery<Movie>(@"
        from index 'Movies/ByVector/Single'
        where vector.search(VectorFromSingle, $queryVector)")
    .AddParameter("queryVector", new RavenVector<float>(new float[]
     {
         6.599999904632568f, 7.699999809265137f
     }))
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession.Advanced
    .AsyncRawQuery<Movie>(@"
        from index 'Movies/ByVector/Single'
        where vector.search(VectorFromSingle, $queryVector)")
    .AddParameter("queryVector", new RavenVector<float>(new float[]
     {
         6.599999904632568f, 7.699999809265137f
     }))
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Movies/ByVector/Single"
where vector.search(VectorFromSingle, $queryVector)
{ "queryVector" : { "@vector" : [6.599999904632568, 7.699999809265137] }}
`}
</CodeBlock>
</TabItem>
</Tabs>

The following index defines a vector field named `VectorFromInt8Arrays`.  
It indexes embeddings generated from the numerical arrays in the `TagsEmbeddedAsInt8` field of all _Movie_ documents.  
The raw numerical data in the source documents is in **Int8 (8-bit integers) format**. 

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`public class Movies_ByVector_Int8 :
    AbstractIndexCreationTask<Movie, Movies_ByVector_Int8.IndexEntry>
{
    public class IndexEntry()
    {
        // This index-field will hold the embeddings that will be generated
        // from the NUMERICAL content in the documents.
        public object VectorFromInt8Arrays { get; set; }
    }
    
    public Movies_ByVector_Int8()
    {
        Map = movies => from movie in movies
            select new IndexEntry
            {
                // Call 'CreateVector' to create a VECTOR FIELD.
                // Pass the document field containing the arrays (8-bit integer values)
                // from which the embeddings will be generated.
                VectorFromInt8Arrays = CreateVector(movie.TagsEmbeddedAsInt8)
            };

        // EITHER - Customize the vector field using VectorOptions:
        VectorIndexes.Add(x => x.VectorFromInt8Arrays,
            new VectorOptions()
            {
                // Define the source embedding type
                SourceEmbeddingType = VectorEmbeddingType.Int8,
                
                // Define the quantization for the destination embedding
                DestinationEmbeddingType = VectorEmbeddingType.Int8,
                
                // It is recommended to configure the number of dimensions
                // which is the size of the arrays that will be indexed.
                Dimensions = 2,
                
                // Optionally, set the number of edges and candidates
                NumberOfEdges = 20,
                NumberOfCandidatesForIndexing = 20
            });
        
        // OR - Customize the vector field using builder:
        Vector(x => x.VectorFromInt8Arrays,
            builder => builder
                .SourceEmbedding(VectorEmbeddingType.Int8)
                .DestinationEmbedding(VectorEmbeddingType.Int8)
                .Dimensions(2)
                .NumberOfEdges(20)
                .NumberOfCandidates(20));

        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JS_index" label="JS_index">
<CodeBlock language="csharp">
{`public class Movies_ByVector_Int8_JS : AbstractJavaScriptIndexCreationTask
{
    public Movies_ByVector_Int8_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Movies', function (movie) {
                   return {
                       VectorFromInt8Arrays: createVector(movie.TagsEmbeddedAsInt8)
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("VectorFromInt8Arrays", new IndexFieldOptions()
        {
            Vector = new VectorOptions()
            {
                SourceEmbeddingType = VectorEmbeddingType.Int8, 
                DestinationEmbeddingType = VectorEmbeddingType.Int8,
                Dimensions = 2,
                NumberOfEdges = 20,
                NumberOfCandidatesForIndexing = 20
            }
        });

        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
<CodeBlock language="csharp">
{`var indexDefinition = new IndexDefinition 
{
    Name = "Movies/ByVector/Int8",

    Maps = new HashSet<string>
    {
        @"
          from movie in docs.Movies
          select new 
          {
              VectorFromInt8Arrays = CreateVector(movie.TagsEmbeddedAsInt8)
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "VectorFromInt8Arrays",
            new IndexFieldOptions()
            {
                Vector = new VectorOptions()
                {
                    SourceEmbeddingType = VectorEmbeddingType.Int8,
                    DestinationEmbeddingType = VectorEmbeddingType.Int8,
                    Dimensions = 2,
                    NumberOfEdges = 20,
                    NumberOfCandidatesForIndexing = 20
                }
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Execute a vector search using the index:  
(Provide a vector as the search term to the `ByEmbedding` method)

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var similarMovies = session
    .Query<Movies_ByVector_Int8.IndexEntry, Movies_ByVector_Int8>()
     // Perform a vector search
     // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
             // Call 'WithField'
             // Specify the index-field in which to search for similar values
            .WithField(x => x.VectorFromInt8Arrays),
        queryVector => queryVector
             // Call 'ByEmbedding'   
             // Provide the vector for the similarity comparison
             // (Note: provide a single vector)
            .ByEmbedding(
                // The provided vector MUST be in the same format as was stored in your document
                // Call 'VectorQuantizer.ToInt8' to transform the rawData to the Int8 format 
                VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f })))
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession
    .Query<Movies_ByVector_Int8.IndexEntry, Movies_ByVector_Int8>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromInt8Arrays),
        queryVector => queryVector
            .ByEmbedding(
                VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f })))
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var similarMovies = session.Advanced
    .DocumentQuery<Movies_ByVector_Int8.IndexEntry, Movies_ByVector_Int8>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromInt8Arrays),
        queryVector => queryVector
            .ByEmbedding(
                VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f })))
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession.Advanced
    .AsyncDocumentQuery<Movies_ByVector_Int8.IndexEntry, Movies_ByVector_Int8>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromInt8Arrays),
        queryVector => queryVector
            .ByEmbedding(
                VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f })))
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var similarMovies = session.Advanced
    .RawQuery<Movie>(@"
        from index 'Movies/ByVector/Int8'
        where vector.search(VectorFromInt8Arrays, $queryVector)")
    .AddParameter("queryVector", VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f }))
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var similarMovies = await asyncSession.Advanced
    .AsyncRawQuery<Movie>(@"
        from index 'Movies/ByVector/Int8'
        where vector.search(VectorFromInt8Arrays, $queryVector)")
    .AddParameter("queryVector", VectorQuantizer.ToInt8(new float[] { 0.1f, 0.2f }))
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Movies/ByVector/Int8"
where vector.search(VectorFromInt8Arrays, $queryVector)
{ "queryVector" : [64, 127, -51, -52, 76, 62] }
`}
</CodeBlock>
</TabItem>
</Tabs>

### Indexing numerical data and querying using text input

The following index defines a vector field named `VectorFromPhoto`.  
It indexes embeddings generated from the numerical data in the `MoviePhotoEmbedding` field of all _Movie_ documents.  

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
```csharp
public class Movies_ByVectorFromPhoto :
    AbstractIndexCreationTask<Movie, Movies_ByVectorFromPhoto.IndexEntry>
{
    public class IndexEntry()
    {
        // This index-field will hold the embeddings that will be generated
        // from the NUMERICAL content in the documents.
        public object VectorFromPhoto { get; set; }
    }
    
    public Movies_ByVectorFromPhoto()
    {
        Map = movies => from movie in movies
            select new IndexEntry
            {
                // Call 'CreateVector' to create a VECTOR FIELD.
                // Pass the document field containing the array 
                // from which the embeddings will be generated.
                VectorFromPhoto = CreateVector(movie.MoviePhotoEmbedding)
            };
        
        // Customize the vector field:
        Vector(x => x.VectorFromPhoto,
            builder => builder
                .SourceEmbedding(VectorEmbeddingType.Single)
                .DestinationEmbedding(VectorEmbeddingType.Single)
                 // Dimensions should match the embedding size, 6 is only for our simple example...
                .Dimensions(6));

        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```csharp
public class Movies_ByVectorFromPhoto_JS : AbstractJavaScriptIndexCreationTask
{
    public Movies_ByVectorFromPhoto_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Movies', function (movie) {
                   return {
                       VectorFromPhoto: createVector(movie.MoviePhotoEmbedding)
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("VectorFromPhoto", new IndexFieldOptions()
        {
            Vector = new VectorOptions()
            {
                SourceEmbeddingType = VectorEmbeddingType.Single,
                DestinationEmbeddingType = VectorEmbeddingType.Single,
                Dimensions = 6, // using 6 only for this simple example
            }
        });
        
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```csharp
var indexDefinition = new IndexDefinition 
{
    Name = "Movies/ByVectorFromPhoto",

    Maps = new HashSet<string>
    {
        @"
          from movie in docs.Movies
          select new 
          {
              VectorFromPhoto = CreateVector(movie.MoviePhotoEmbedding)
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "VectorFromPhoto",
            new IndexFieldOptions()
            {
                Vector = new VectorOptions()
                {
                    SourceEmbeddingType = VectorEmbeddingType.Single,
                    DestinationEmbeddingType = VectorEmbeddingType.Single,
                    Dimensions = 6, // using 6 only for this simple example
                }
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
```
</TabItem>
</Tabs>

Execute a vector search using the index:  

  * Pass a textual search term to the `ByText` method,  
    along with the ID of the embedding generation task that will convert the text into an embedding.
  
  * The query is only meaningful if the vector field being searched contains numerical embeddings  
    generated using the same model as the one configured in the specified task.
  
  * If the specified task ID is not found, RavenDB will throw an `InvalidQueryException`.  
    To avoid this error, you can verify that the specified embeddings generation task exists before issuing the query.  
    See [Get embeddings generation task details](../ai-integration/generating-embeddings/overview#get-embeddings-generation-task-details)
    to learn how to check which tasks are defined and what their identifiers are.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```csharp
// Query for movies with images related to 'NASA'
var similarMovies = session
    .Query<Movies_ByVectorFromPhoto.IndexEntry, Movies_ByVectorFromPhoto>()
    // Perform a vector search
    // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
            // Call 'WithField'
            // Specify the index field that stores the image embeddings
            .WithField(x => x.VectorFromPhoto),
        queryVector => queryVector
            // Call 'ByText'
            // Provide a textual description to be embedded by the same multimodal model
            // used for the MoviePhotoEmbedding field
            .ByText("NASA", "id-of-embedding-generation-task"),
        // As with any other vector search query, you can optionally specify
        // 'minimumSimilarity', 'numberOfCandidates', and 'isExact'
        minimumSimilarity: 0.85f)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToList();
```
</TabItem>
<TabItem value="Query_async" label="Query_async">
```csharp
var similarMovies = await asyncSession
    .Query<Movies_ByVectorFromPhoto.IndexEntry, Movies_ByVectorFromPhoto>()
    .VectorSearch(
        field => field.WithField(x => x.VectorFromPhoto),
        queryVector => queryVector.ByText("NASA", "id-of-embedding-generation-task"),
     minimumSimilarity: 0.85f)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Movie>()
    .ToListAsync();
```
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
```csharp
var similarMovies = session.Advanced
    .DocumentQuery<Movies_ByVectorFromPhoto.IndexEntry, Movies_ByVectorFromPhoto>()
    .VectorSearch(
         field => field.WithField(x => x.VectorFromPhoto),
         queryVector => queryVector.ByText("NASA", "id-of-embedding-generation-task"), 0.85f)
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToList();
```
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
```csharp
var similarMovies = await asyncSession.Advanced
    .AsyncDocumentQuery<Movies_ByVectorFromPhoto.IndexEntry, Movies_ByVectorFromPhoto>()
    .VectorSearch(
        "VectorFromPhoto",
        queryVector => queryVector.ByText("NASA", "id-of-embedding-generation-task"), 0.85f)
    .WaitForNonStaleResults()
    .OfType<Movie>()
    .ToListAsync();
```
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
```csharp
var similarMovies = session
    .Advanced
    .RawQuery<Movie>(@"
        from index 'Movies/ByVectorFromPhoto'
        where vector.search(VectorFromPhoto, embedding.text($searchTerm, ai.task($embeddingTaskId)), 0.85, null)
    ")
    .AddParameter("searchTerm", "NASA")
    .AddParameter("embeddingTaskId", "id-of-embedding-generation-task")
    .ToList();
```
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
```csharp
var similarMovies = await asyncSession
    .Advanced
    .RawQuery<Movie>(@"
        from index 'Movies/ByVectorFromPhoto'
        where vector.search(VectorFromPhoto, embedding.text($searchTerm, ai.task($embeddingTaskId)), 0.85, null)
    ")
    .AddParameter("searchTerm", "NASA")
    .AddParameter("embeddingTaskId", "id-of-embedding-generation-task")
    .ToListAsync();
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
from index 'Movies/ByVectorFromPhoto'
where vector.search(VectorFromPhoto, embedding.text($searchTerm, ai.task($embeddingTaskId)), 0.85, null)
{ "searchTerm" : "NASA", "embeddingTaskId" : "id-of-embedding-generation-task" }
```
</TabItem>
</Tabs>

---

## Indexing multiple field types

An index can define multiple types of index-fields. In this example, the index includes:  
A _'regular'_ field, a _'vector'_ field, and a field configured for [full-text search](../../../indexes/querying/searching.mdx).  
This allows you to query across all fields using various predicates.

<Tabs groupId='languageSyntax'>
<TabItem value="LINQ_index" label="LINQ_index">
<CodeBlock language="csharp">
{`public class Products_ByMultipleFields :
    AbstractIndexCreationTask<Product, Products_ByMultipleFields.IndexEntry>
{
    public class IndexEntry()
    {
        // An index-field for 'regular' data
        public decimal PricePerUnit { get; set; }
        
        // An index-field for 'full-text' search
        public string Name { get; set; }
        
        // An index-field for 'vector' search
        public object VectorFromText { get; set; }
    }
    
    public Products_ByMultipleFields()
    {
        Map = products => from product in products
            select new IndexEntry
            {
                PricePerUnit = product.PricePerUnit,
                Name = product.Name,
                VectorFromText = CreateVector(product.Name)
            };
        
        // Configure the index-field 'Name' for FTS:
        Index(x => x.Name, FieldIndexing.Search);
        
        // Note:
        // Default values will be used for the VECTOR FIELD if not customized here.
        
        // The index MUST use the Corax search engine 
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="JS_index" label="JS_index">
<CodeBlock language="csharp">
{`public class Products_ByMultipleFields_JS : AbstractJavaScriptIndexCreationTask
{
    public Products_ByMultipleFields_JS()
    {
        Maps = new HashSet<string>()
        {
            @"map('Products', function (product) {
                   return {
                       PricePerUnit: product.PricePerUnit,
                       Name: product.Name,
                       VectorFromText: createVector(product.Name)
                   };
            })"
        };
    
        Fields = new();
        Fields.Add("Name", new IndexFieldOptions()
        {
            Indexing = FieldIndexing.Search
        });

        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Corax;
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
<CodeBlock language="csharp">
{`var indexDefinition = new IndexDefinition
{
    Name = "Products/ByMultipleFields",
    Maps = new HashSet<string>
    {
        @"
          from product in docs.Products
          select new 
          {
              PricePerUnit = product.PricePerUnit,
              Name = product.Name,
              VectorFromText  = CreateVector(product.Name)
          }"
    },
    
    Fields = new Dictionary<string, IndexFieldOptions>()
    {
        {
            "Name",
            new IndexFieldOptions()
            {
                Indexing = FieldIndexing.Search
            }
        }
    },
    
    Configuration = new IndexConfiguration()
    {
        ["Indexing.Static.SearchEngineType"] = "Corax"
    }
};

store.Maintenance.Send(new PutIndexesOperation(indexDefinition));
`}
</CodeBlock>
</TabItem>
</Tabs>

Execute a query that combines predicates across all index-field types:  

<Tabs groupId='languageSyntax'>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var results = session.Advanced
    .DocumentQuery<Products_ByMultipleFields.IndexEntry, Products_ByMultipleFields>()
     // Perform a regular search
    .WhereGreaterThan(x => x.PricePerUnit, 200)
    .OrElse()
     // Perform a full-text search
    .Search(x => x.Name, "Alice")
    .OrElse()
     // Perform a vector search
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
            .ByText("italian food"),
        minimumSimilarity: 0.8f)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var results = await asyncSession.Advanced
    .AsyncDocumentQuery<Products_ByMultipleFields.IndexEntry, Products_ByMultipleFields>()
    .WhereGreaterThan(x => x.PricePerUnit, 200)
    .OrElse()
    .Search(x => x.Name, "Alice")
    .OrElse()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        searchTerm => searchTerm
            .ByText("italian food"),
        minimumSimilarity: 0.8f)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var results = session.Advanced
    .RawQuery<Product>(@"
        from index 'Products/ByMultipleFields'
        where PricePerUnit > $minPrice
        or search(Name, $searchTerm1)
        or vector.search(VectorFromText, $searchTerm2, 0.8)")
    .AddParameter("minPrice", 200)
    .AddParameter("searchTerm1", "Alice")
    .AddParameter("searchTerm2", "italian")
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var results = await asyncSession.Advanced
    .AsyncRawQuery<Product>(@"
        from index 'Products/ByMultipleFields'
        where PricePerUnit > $minPrice
        or search(Name, $searchTerm1)
        or vector.search(VectorFromText, $searchTerm2, 0.8)")
    .AddParameter("minPrice", 200)
    .AddParameter("searchTerm1", "Alice")
    .AddParameter("searchTerm2", "italian")
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByMultipleFields"
where PricePerUnit > $minPrice
or search(Name, $searchTerm1)
or vector.search(VectorFromText, $searchTerm2, 0.8)
{ "minPrice" : 200, "searchTerm1" : "Alice", "searchTerm2": "italian" }
`}
</CodeBlock>
</TabItem>
</Tabs>

---

## Querying the static index for similar documents

* Similar to [querying for similar documents using a dynamic query](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#dynamic-vector-search---querying-for-similar-documents),  
  you can **query a static-index for similar documents** by specifying a document ID in the vector search.

* The following example queries the static-index defined in [this example](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---text) above.
  The document for which we want to find similar documents is specified by the document ID passed to the `ForDocument` method.

* RavenDB retrieves the embedding that was indexed for the queried field in the specified document and uses it as the query vector for the similarity comparison.

* The results will include documents whose indexed embeddings are most similar to the one stored in the referenced document’s index-entry.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`var similarProducts = session
    .Query<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    // Perform a vector search
    // Call the 'VectorSearch' method
    .VectorSearch(
        field => field
            // Call 'WithField'
            // Specify the index-field in which to search for similar values
            .WithField(x => x.VectorFromText),
        embedding => embedding
            // Call 'ForDocument'
            // Provide the document ID for which you want to find similar documents.
            // The embedding stored in the index for the specified document
            // will be used as the "query vector".
            .ForDocument("Products/7-A"),
        // Optionally, specify the minimum similarity value
        minimumSimilarity: 0.82f)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`var similarCategories = await asyncSession
    .Query<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        embedding => embedding
            .ForDocument("Products/7-A"),
        minimumSimilarity: 0.82f)
    .Customize(x => x.WaitForNonStaleResults())
    .OfType<Category>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`var similarProducts = session.Advanced
    .DocumentQuery<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        embedding => embedding
            .ForDocument("Products/7-A"),
        minimumSimilarity: 0.82f)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery_async" label="DocumentQuery_async">
<CodeBlock language="csharp">
{`var similarProducts = await asyncSession.Advanced
    .AsyncDocumentQuery<Products_ByVector_Text.IndexEntry, Products_ByVector_Text>()
    .VectorSearch(
        field => field
            .WithField(x => x.VectorFromText),
        embedding => embedding
            .ForDocument("Products/7-A"),
        minimumSimilarity: 0.82f)
    .WaitForNonStaleResults()
    .OfType<Product>()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
<CodeBlock language="csharp">
{`var similarProducts = session.Advanced
    .RawQuery<Product>(@"
        from index 'Products/ByVector/Text'
        // Pass a document ID to the 'forDoc' method to find similar documents
        where vector.search(VectorFromText, embedding.forDoc($documentID), 0.82)")
    .AddParameter("$documentID", "Products/7-A")
    .WaitForNonStaleResults()
    .ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RawQuery_async" label="RawQuery_async">
<CodeBlock language="csharp">
{`var similarProducts = await asyncSession.Advanced
    .AsyncRawQuery<Product>(@"
        from index 'Products/ByVector/Text'
        // Pass a document ID to the 'forDoc' method to find similar documents
        where vector.search(VectorFromText, embedding.forDoc($documentID), 0.82)")
    .AddParameter("$documentID", "Products/7-A")
    .WaitForNonStaleResults()
    .ToListAsync();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByVector/Text"
// Pass a document ID to the 'forDoc' method to find similar documents
where vector.search(VectorFromText, embedding.forDoc($documentID), 0.82)
{"documentID" : "Products/7-A"}
`}
</CodeBlock>
</TabItem>
</Tabs>

Running the above example on RavenDB’s sample data returns the following documents that have similar content in their _Name_ field:
(Note: the results include the referenced document itself, _Products/7-A_)

<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`// ID: products/7-A  ... Name: "Uncle Bob's Organic Dried Pears"
// ID: products/51-A ... Name: "Manjimup Dried Apples"
// ID: products/6-A  ... Name: "Grandma's Boysenberry Spread"
`}
</CodeBlock>
</TabItem>

---

## Configure the vector field in the Studio

  ![Add vector field](../assets/add-vector-field-1.png)

  ![Customize vector field](../assets/add-vector-field-2.png)

1. **Vector field name**  
   Enter the name of the vector field to customize.
2. **Configure Vector Field**  
   Click this button to customize the field.
3. **Dimensions**  
   For numerical input only - define the size of the array from your source document.
4. **Edges**  
   The number of edges that will be created for a vector during indexing.
5. **Source embedding type**  
   The format of the source embeddings (Text, Single, Int8, or Binary).
6. **Candidates for indexing**  
   The number of candidates (potential neighboring vectors) that RavenDB evaluates during vector indexing.
7. **Destination embedding type**  
   The quantization format for the embeddings that will be generated (Text, Single, Int8, or Binary).
