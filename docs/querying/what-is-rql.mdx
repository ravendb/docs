---
title: "RQL - Raven Query Language"
sidebar_label: "What is RQL"
sidebar_position: 1
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";
import Panel from "@site/src/components/Panel";
import ContentFrame from "@site/src/components/ContentFrame";

<Admonition type="note" title="">

* Queries in RavenDB use a SQL-like language called **RQL** (Raven Query Language).

* RQL exposes the RavenDB query pipeline in a straightforward and accessible manner  
  that is easy to use and interact with.

* Any query written using high-level Session methods (`Query`, `DocumentQuery`)  
  is translated by the client to RQL before being sent to the server for execution.

* A query can be written with RQL directly by either:  
  * Using the session's `RawQuery` method  
  * Making a query from the [Query view](../studio/database/queries/query-view.mdx) in Studio  

* Learn more about querying from the session in this [Query Overview](../querying/overview.mdx). 

* In this article:  

  * [The query pipeline](../querying/what-is-rql.mdx#the-query-pipeline)  
  * [RQL keywords and methods](../querying/what-is-rql.mdx#rql-keywords-and-methods)  
     * [`declare`](../querying/what-is-rql.mdx#declare)  
     * [`from`](../querying/what-is-rql.mdx#from)
     * [`where`](../querying/what-is-rql.mdx#where)
     * [`group by`](../querying/what-is-rql.mdx#group-by)
     * [`include`](../querying/what-is-rql.mdx#include)
     * [`order by`](../querying/what-is-rql.mdx#order-by)
     * [`select`](../querying/what-is-rql.mdx#select)
     * [`load`](../querying/what-is-rql.mdx#load)
     * [`limit`](../querying/what-is-rql.mdx#limit)
     * [`update`](../querying/what-is-rql.mdx#update)    
  * [RQL comments](../querying/what-is-rql.mdx#rql-comments)

</Admonition>

<Panel heading="The query pipeline">

The query pipeline in RavenDB includes the following main stages:  

1. **Detect query source** ([`from`](../querying/what-is-rql.mdx#from))

   * Based on your query, RavenDB will determine the appropriate data source from which to retrieve results.           
   * The following options are available:     
     * `from index` - Explicitly specify which index to use.   
     * `from collection` - Specify the collection to query.  
       RavenDB will decide which index will be used depending on the query criteria.
   * Note: all queries in RavenDB use an index to provide results, even when you don't specify one.  
     Learn more about these **query scenarios** in this [Query Overview](../querying/overview.mdx#queries-always-provide-results-using-an-index).

2. **Filter the data** ([`where`](../querying/what-is-rql.mdx#where))  
   * The index is scanned for records that match the query predicate. 

3. **Include related documents**  ([`include`](../querying/what-is-rql.mdx#include))
    * [Related documents](../client-api/how-to/handle-document-relationships.mdx#includes) that are included in the query will be retrieved and returned to the client  
      along with the resulting matching documents, reducing the need to do another network round trip  
      to the database when accessing the included documents.

4. **Sort results** ([`order by`](../querying/what-is-rql.mdx#order-by)) 
   * Query results can be sorted.  
     For example, you can order by a field value, by the resulting documents' score, by random ordering, etc.

5. **Limit results** ([`limit`](../querying/what-is-rql.mdx#limit))
   * You can specify the number of results you want to get back from the query  
     and the number of results you want to skip.

6. **Project results** ([`select`](../querying/what-is-rql.mdx#select)) 
   * [Projections](../indexes/querying/projections.mdx) are specified when you need to retrieve only specific document fields, instead of the whole full document.
     This reduces the amount of data sent over the network and is useful when only partial data is needed.
     When projections are Not defined on the query - then the full document content is retrieved from the document storage.

   * Projections are applied as the last stage after the query has been processed, filtered, sorted, and paged.  
     This means that the projection doesn't apply to all the documents in the database,  
     only to the results that are actually returned.

   * Data can be loaded ([`load`](../querying/what-is-rql.mdx#load)) from related documents to be used in the projected fields.  
   
   * For each record, the server extracts the requested field:  
     If a field is stored in the index - the server will fetch it from the index.  
     If a field is Not stored in the index - the server will fetch it from the document storage.  

6. **Return results** to the client.

</Panel>

<Panel heading="RQL keywords and methods">

The following keywords and methods are available in RQL:

- [DECLARE](../querying/what-is-rql.mdx#declare)
- [FROM](../querying/what-is-rql.mdx#from)
    - index
- [GROUP BY](../querying/what-is-rql.mdx#group-by)
    - [array()](../client-api/session/querying/how-to-perform-group-by-query.mdx#by-array-content)
- [WHERE](../querying/what-is-rql.mdx#where)
    - id()
    - [search()](../client-api/session/querying/text-search/full-text-search.mdx)
    - cmpxchg()
    - [boost()](../client-api/session/querying/text-search/boost-search-results.mdx)
    - [regex()](../client-api/session/querying/text-search/using-regex.mdx)
    - [startsWith()](../client-api/session/querying/text-search/starts-with-query.mdx)
    - [endsWith()](../client-api/session/querying/text-search/ends-with-query.mdx)
    - [lucene()](../client-api/session/querying/document-query/how-to-use-lucene.mdx)
    - [exists()](../client-api/session/querying/how-to-filter-by-field.mdx)
    - [exact()](../client-api/session/querying/text-search/exact-match-query.mdx)
    - [intersect()](../indexes/querying/intersection.mdx)
    - [spatial.within()](../indexes/querying/spatial.mdx)
    - [spatial.contains()](../indexes/querying/spatial.mdx)
    - [spatial.disjoint()](../indexes/querying/spatial.mdx)
    - [spatial.intersects()](../indexes/querying/spatial.mdx)
    - [moreLikeThis()](../client-api/session/querying/how-to-use-morelikethis.mdx)
    - [vector.search()](../ai-integration/vector-search/vector-search-using-dynamic-query.mdx)
- [ORDER BY](../querying/what-is-rql.mdx#order-by)
    - [ASC | ASCENDING](../indexes/querying/sorting.mdx#basics)
    - [DESC | DESCENDING](../indexes/querying/sorting.mdx#basics)
    - [AS](../indexes/querying/sorting.mdx#basics)
        - [string](../indexes/querying/sorting.mdx#basics)
        - [long](../indexes/querying/sorting.mdx#basics)
        - [double](../indexes/querying/sorting.mdx#basics)
        - [alphaNumeric](../indexes/querying/sorting.mdx#alphanumeric-ordering)
    - [random()](../indexes/querying/sorting.mdx#random-ordering)
    - [score()](../indexes/querying/sorting.mdx#ordering-by-score)
    - [spatial.distance()](../client-api/session/querying/how-to-make-a-spatial-query.mdx#spatial-sorting)
- [LOAD](../querying/what-is-rql.mdx#load)
- [SELECT](../querying/what-is-rql.mdx#select)
    - DISTINCT
    - key()
    - sum()
    - count()
    - [facet()](../indexes/querying/faceted-search.mdx)
    - [timeseries()](../document-extensions/timeseries/querying/overview-and-syntax.mdx#syntax)
    - [counter()](../document-extensions/counters/counters-and-other-features.mdx#counters-and-queries)
- [LIMIT](../querying/what-is-rql.mdx#limit)
- [UPDATE](../querying/what-is-rql.mdx#update)
- [INCLUDE](../querying/what-is-rql.mdx#include)

With the following operators:

- &gt;=
- &lt;=
- &lt;&gt; or !=
- &lt;
- &gt;
- = or ==
- BETWEEN
- IN
- ALL IN
- OR
- AND
- NOT
- (
- )

And the following values:

- true
- false
- null
- string e.g. 'John' or "John"
- number (long and double) e.g. 17
- parameter e.g. $param1

---
    
## `declare`

You can use the `declare` keyword to create a JavaScript function that can then be called from a `select` clause when using a projection. 
JavaScript functions add flexibility to your queries as they can be used to manipulate and format retrieved results.  

<TabItem>
```javascript
// Declare a JavaScript function 
declare function output(employee) {
    // Format the value that will be returned in the projected field 'FullName'
    var formatName = function(x){ return x.FirstName + " " + x.LastName; };
    return { FullName : formatName(employee) };
}

// Query with projection calling the 'output' JavaScript function
from Employees as employee select output(employee)
```
</TabItem>

Values are returned from a declared Javascript function as a set of values rather than in a nested array to ease the projection of retrieved values.
See an example for this usage [here](../document-extensions/timeseries/querying/overview-and-syntax.mdx#combine-time-series-and-javascript-functions).  

---

## `from`

The keyword `from` is used to determine the source data that will be used when the query is executed.  
The following options are available:
    
<ContentFrame>

#### Query a specific collection: &nbsp;&nbsp; `from <collection-name>`

<TabItem>
```csharp
// Full collection query 
// Data source: The raw collection documents (Auto-index is Not created)
from "Employees"
```
</TabItem>

<TabItem>
```csharp
// Collection query - by ID 
// Data source: The raw collection documents (Auto-index is Not created)
from "Employees" where id() = "employees/1-A"
```
</TabItem>

<TabItem>
```csharp
// Dynamic query - with filtering
// Data source: Auto-index (server uses an existing auto-index or creates a new one)
from "Employees" where FirstName = "Laura"
```
</TabItem>

</ContentFrame>

<ContentFrame>

#### Query all documents: &nbsp;&nbsp; `from @all_docs`

<TabItem>
```csharp
// All collections query
// Data source: All raw collections (Auto-index is Not created)
from @all_docs
```
</TabItem>

<TabItem>
```csharp
// Dynamic query - with filtering 
// Data source: Auto-index (server uses an existing auto-index or creates a new one)
from @all_docs where FirstName = "Laura"
```
</TabItem>

</ContentFrame>

<ContentFrame>

#### Query an index: &nbsp;&nbsp; `from index <index-name>`

<TabItem>
```csharp
// Index query
// Data source: The specified index
from index "Employees/ByFirstName"
```
</TabItem>

<TabItem>
```csharp
// Index query - with filtering
// Data source: The specified index
from index "Employees/ByFirstName" where FirstName = "Laura"
```
</TabItem>

</ContentFrame>
   
---
    
## `where`

Use the `where` keyword with various operators to filter chosen documents from the final result-set.  
    
<ContentFrame>

#### Operator: &nbsp;&nbsp; `>=`, `<=`, `<>`, `!=`, `<`, `>`, `=`, `==`

These basic operators can be used with all value types, including 'numbers' and 'strings'.  
For example, you can return every document from the [Companies collection](../client-api/faq/what-is-a-collection.mdx) 
whose _field value_ **=** _a given input_.  

<TabItem>
```csharp
from "Companies"
where Name == "The Big Cheese" // Can use either '=' or'==' 
```
</TabItem>

Filtering on **nested properties** is also supported.  
So in order to return all companies from 'Albuquerque' we need to execute following query:  

<TabItem>
```csharp
from "Companies"
where Address.City = "Albuquerque"
```
</TabItem>

</ContentFrame>
    
<ContentFrame>

#### Operator: &nbsp;&nbsp; `between`

The operator `between` returns results inclusively, and the type of border values used must match.  
It works on both 'numbers' and 'strings' and can be substituted with the `>=` and `<=` operators.

<TabItem>
```csharp
from "Products" 
where PricePerUnit between 10.5 and 13.0 // Using between
```
</TabItem>

<TabItem>
```csharp
from "Products" 
where PricePerUnit >= 10.5 and PricePerUnit <= 13.0 // Using >= and <=
```
</TabItem>

</ContentFrame>
    
<ContentFrame>

#### Operator: &nbsp;&nbsp; `in`

The operator `in` is validating if a given field contains passed values.  
It will return results if a given field matches **any** of the passed values.

<TabItem>
```csharp
from "Companies" 
where Name in ("The Big Cheese", "Unknown company name")
```
</TabItem>

<TabItem>
```csharp
from "Orders" 
where Lines[].ProductName in ("Chang", "Spegesild", "Unknown product name") 
```
</TabItem>

</ContentFrame>
    
<ContentFrame>

#### Operator: &nbsp;&nbsp; `all in`

This operator checks if **all** passes values are matching a given field.  
Due to its mechanics, it is only useful when used on array fields.

The following query will yield no results in contrast to the `in` operator.

<TabItem>
```csharp
from "Orders" 
where Lines[].ProductName all in ("Chang", "Spegesild", "Unknown product name")
```
</TabItem>

Removing 'Unknown product name' will return only orders that contain products with both  
'Chang' and 'Spegesild' names.

<TabItem>
```csharp
from "Orders" 
where Lines[].ProductName all in ("Chang", "Spegesild") 
```
</TabItem>

</ContentFrame>
    
<ContentFrame>

#### Binary Operators: &nbsp;&nbsp; `AND`, `OR`, `NOT`

Binary operators can be used to build more complex statements.  
The `NOT` operator can only be used with one of the other binary operators creating `OR NOT` or `AND NOT` ones.

<TabItem>
```csharp
from "Companies"
where Name = "The Big Cheese" OR Name = "Richter Supermarkt"
```
</TabItem>

<TabItem>
```csharp
from "Orders"
where Freight > 500 AND ShippedAt > '1998-01-01'
```
</TabItem>

<TabItem>
```csharp
from "Orders"
where Freight > 500 AND ShippedAt > '1998-01-01' AND NOT Freight = 830.75
```
</TabItem>

</ContentFrame>
    
<ContentFrame>

#### Subclauses: &nbsp;&nbsp; `(`, `)`

Subclauses can be used along with binary operators to build even more complex logical statements.  

</ContentFrame>

---

## `group by`

The keyword `group by` is used to create an aggregation query.  
Learn more in [dynamic group by queries](../client-api/session/querying/how-to-perform-group-by-query.mdx).

---

## `include`

The keyword `include` has been introduced to support:

- [including related documents](../client-api/how-to/handle-document-relationships.mdx#includes) in the query response
- [including counters](../document-extensions/counters/counters-and-other-features.mdx#including-counters),
  [time series](../document-extensions/timeseries/client-api/session/include/with-raw-queries.mdx),
  or [revisions](../document-extensions/revisions/client-api/session/including.mdx#include-revisions-when-making-a-raw-query) in the query response
- [including compare-exchange items](../compare-exchange/include-cmpxchg-items#include-cmpxchg-items-when-querying) in the query response
- [highlighting](../client-api/session/querying/text-search/highlight-query-results.mdx) results
- [get query timings](../client-api/session/querying/debugging/query-timings.mdx)
- [get explanations](../client-api/session/querying/debugging/include-explanations.mdx)

---

## `order by`

Use `order by` to perform sorting.  
Learn more in this [sorting](../indexes/querying/sorting.mdx) article.  

---

## `select`

Use `select` to have the query return a projection instead of the full document.  
Learn more in this [projection](../indexes/querying/projections.mdx) article.

---

## `load`

Use `load`when you need to use data from a related document in projection.  
See an example in this [projection](../indexes/querying/projections.mdx#example-viii---projection-using-a-loaded-document) article.

---

## `limit`

Use `limit` to limit the number of results returned by the query.  
Specify the number of items to **skip** from the beginning of the result set and the number of items to **take** (return).  
This is useful when [paging](../indexes/querying/paging.mdx) results.

<TabItem>
```csharp
// Available syntax options:
// =========================

from "Products" limit 5, 10       // skip 5, take 10

from "Products" limit 10 offset 5 // skip 5, take 10

from "Products" offset 5          // skip 5, take all the rest
```
</TabItem>

---

## `update`

To patch documents on the server-side, use `update` with the desired JavaScript that will be applied to any document matching the query criteria.  
For more information, please refer to this [patching](../client-api/operations/patching/set-based.mdx) article.  

</Panel>

<Panel heading="RQL comments">

<ContentFrame>

#### Single-line comments  

Single-line comments start with `//` and end at the end of that line.

<TabItem>
```csharp
// This is a single-line comment.
from "Companies" 
where Name = "The Big Cheese" OR Name = "Richter Supermarkt"
```
</TabItem>

<TabItem>
```csharp
from "Companies"
where Name = "The Big Cheese" // OR Name = "Richter Supermarkt"
```
</TabItem>

</ContentFrame>

<ContentFrame>

#### Multiline comments

Multiline comments start with `/*` and end with `*/`.

<TabItem>
```csharp
/*
This is a multiline comment.
Any text here will be ignored.
*/
from "Companies"
where Name = "The Big Cheese" OR Name = "Richter Supermarkt"
```
</TabItem>

<TabItem>
```csharp
from "Companies"
where Name = "The Big Cheese" /* this part is a comment */ OR Name = "Richter Supermarkt"
```
</TabItem>

</ContentFrame>
    
</Panel>