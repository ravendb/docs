---
title: "Full-Text Search with Index"
sidebar_label: Full-Text Search
sidebar_position: 7
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

export const supportedLanguages = ["csharp", "java", "python", "php", "nodejs"];


# Full-Text Search with Index
<LanguageSwitcher supportedLanguages={supportedLanguages} />
<LanguageContent language="csharp">

<Admonition type="note" title="Note">

* Prior to this article, please refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) to learn about the `Search` method.  

* **All capabilities** provided by `Search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers#selecting-an-analyzer-for-a-field).    
* In this article:
  * [Indexing single field for FTS](../../indexes/querying/searching#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../indexes/querying/searching#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../indexes/querying/searching#boosting-search-results)
  * [Searching with wildcards](../../indexes/querying/searching#searching-with-wildcards)
      * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching#when-usingoror)
      * [When using a custom analyzer](../../indexes/querying/searching#when-using-a-custom-analyzer)
      * [When using the Exact analyzer](../../indexes/querying/searching#when-using-the-exact-analyzer)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="something" label="index_1">
<CodeBlock language="csharp">
{`public class Employees_ByNotes :
    AbstractIndexCreationTask<Employee, Employees_ByNotes.IndexEntry>
\{
    // The IndexEntry class defines the index-fields
    public class IndexEntry
    \{
        public string EmployeeNotes \{ get; set; \}
    \}

    public Employees_ByNotes()
    \{
        // The 'Map' function defines the content of the index-fields
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeNotes = employee.Notes[0]
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeNotes'
        Index(x => x.EmployeeNotes, FieldIndexing.Search);
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        Analyze(x => x.EmployeeNotes, "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the index
    .DocumentQuery<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="something" label="index_2">
<CodeBlock language="csharp">
{`public class Employees_ByEmployeeData : 
    AbstractIndexCreationTask<Employee, Employees_ByEmployeeData.IndexEntry>
\{
    public class IndexEntry
    \{
        public object[] EmployeeData \{ get; set; \}
    \}

    public Employees_ByEmployeeData()
    \{
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeData = new object[]
                \{
                    // Multiple document-fields can be indexed
                    // into the single index-field 'EmployeeData' 
                    employee.FirstName,
                    employee.LastName,
                    employee.Title,
                    employee.Notes
                \}
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeData'
        Index(x => x.EmployeeData, FieldIndexing.Search);
        
        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the static-index
    .DocumentQuery<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
    .OpenSubclause()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .CloseSubclause()
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//                                                                                                                                                                                                                                                                                                                  
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly,
  use the `AsJson` method in the _Map_ function to extract all property values and index them in a single searchable field.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`, 
  the index automatically includes values from ALL existing and newly added properties 
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="Info">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="something" label="index_6">
<CodeBlock language="csharp">
{`public class Products_ByAllValues : 
    AbstractIndexCreationTask<Product, Products_ByAllValues.IndexEntry>
\{
    public class IndexEntry
    \{
        // This index field will contain all values from all properties in the document
        public string AllValues \{ get; set; \}
                
        // Note:
        // RavenDB seamlessly supports multi-value indexing on this field.
        // Even though the 'AllValues' index-field is declared as a 'string',
        // it can accept a collection of values, as defined in the Map function.
        // The engine treats the field as if it contains multiple strings
        // and indexes each one individually.
    \}

    public Products_ByAllValues()
    \{
        Map = products => from product in products
            select new
            \{
                // Use the 'AsJson' method to convert the document into a JSON-like structure
                // and call 'Select' to extract only the values of each property
                AllValues = AsJson(product).Select(x => x.Value)
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'AllValues'
        Index(x => x.AllValues, FieldIndexing.Search);
        
        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
        
        // Set the search engine type to Lucene:
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Lucene;
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToList();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToListAsync();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToList();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(AllValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results).



## Searching with wildcards

* When making a full-text search with wildcards in the search terms, 
  the presence of wildcards (`*`) in the terms sent to the search engine is determined by the transformations applied by the
  [analyzer](../../indexes/using-analyzers) used in the index.

* Note the different behavior in the following cases, as described below:  
  * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching#when-usingoror)
  * [When using a custom analyzer](../../indexes/querying/searching#when-using-a-custom-analyzer)
  * [When using the Exact analyzer](../../indexes/querying/searching#when-using-the-exact-analyzer)

* When using [Corax](../../indexes/search-engine/corax) as the search engine,  
  this behavior will only apply to indexes that are newly created or have been reset.
<Admonition type="note" title="Note">

##### When using&nbsp;`RavenStandardAnalyzer`&nbsp;or`StandardAnalyzer`&nbsp;or&nbsp;`NGramAnalyzer`:
Usually, the same analyzer used to tokenize field content at **indexing time** is also used to process the terms provided in the **full-text search query**
before they are sent to the search engine to retrieve matching documents.

**However, in the following cases**:

* When making a [dynamic search query](../../client-api/session/querying/text-search/full-text-search)
* or when querying a static index that uses the default [RavenStandardAnalyzer](../../indexes/using-analyzers#using-the-default-search-analyzer)
* or when querying a static index that uses the [StandardAnalyzer](../../indexes/using-analyzers#analyzers-that-remove-common-stop-words)
* or when querying a static index that uses the [NGramAnalyzer](../../indexes/using-analyzers#analyzers-that-tokenize-according-to-the-defined-number-of-characters)

the queried terms in the _Search_ method are processed with the [LowerCaseKeywordAnalyzer](../../indexes/using-analyzers#using-the-default-analyzer)  
before being sent to the search engine.

This analyzer does Not remove the `*`, so the terms are sent with `*`, as provided in the search terms.  
For example:  

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByNotes_usingDefaultAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByNotes_usingDefaultAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string EmployeeNotes { get; set; }
    }

    public Employees_ByNotes_usingDefaultAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                EmployeeNotes = employee.Notes[0]
            };

        // Configure the index-field for FTS:
        Index(x => x.EmployeeNotes, FieldIndexing.Search);

        // Since no analyzer is explicitly set
        // then the default 'RavenStandardAnalyzer' will be used at indexing time.
        
        // However, when making a search query with wildcards,
        // the 'LowerCaseKeywordAnalyzer' will be used to process the search terms
        // prior to sending them to the search engine. 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToListAsync();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .IncludeExplanations(out var explanations)
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/usingDefaultAnalyzer"
where search(EmployeeNotes, "*rench")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### When using a custom analyzer:
* When setting a [custom analyzer](../../indexes/using-analyzers#creating-custom-analyzers) in your index to tokenize field content,
  then when querying the index, the search terms in the query will be processed according to the **custom analyzer's logic**.

* The `*` will remain in the terms if the custom analyzer allows it.
  It is the userâ€™s responsibility to ensure that wildcards are not removed by the custom analyzer if they should be included in the query.

* Note:  
  An exception to the above is when the wildcard is used as a suffix in the search term (e.g. `Fren*`).  
  In this case the wildcard will be included in the query regardless of the analyzer's logic.

For example:  

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByNotes_usingCustomAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByNotes_usingCustomAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string EmployeeNotes { get; set; }
    }

    public Employees_ByNotes_usingCustomAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                EmployeeNotes = employee.Notes[0]
            };

        // Configure the index-field for FTS:
        Index(x => x.EmployeeNotes, FieldIndexing.Search);
        
        // Set a custom analyzer for the index-field:
        Analyze(x => x.EmployeeNotes, "CustomAnalyzers.RemoveWildcardsAnalyzer");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Custom_analyzer" label="Custom_analyzer">
<CodeBlock language="csharp">
{`// The custom analyzer:
// ====================

const string RemoveWildcardsAnalyzer =
    @"
      using System.IO;
      using Lucene.Net.Analysis; 
      using Lucene.Net.Analysis.Standard;
      namespace CustomAnalyzers
      {
          public class RemoveWildcardsAnalyzer : StandardAnalyzer
          {
              public RemoveWildcardsAnalyzer() : base(Lucene.Net.Util.Version.LUCENE_30)
              {
              }

              public override TokenStream TokenStream(string fieldName, System.IO.TextReader reader)
              {
                   // Read input stream and remove wildcards (*)
                  string text = reader.ReadToEnd();
                  string processedText = RemoveWildcards(text);
                  StringReader newReader = new StringReader(processedText);
                  
                  return base.TokenStream(fieldName, newReader);
              }

              private string RemoveWildcards(string input)
              {
                  // Replace wildcard characters with an empty string
                  return input.Replace(""*"", """");
              }
          }
      }";

// Deploying the custom analyzer:
// ==============================

store.Maintenance.Send(new PutAnalyzersOperation(new AnalyzerDefinition()
{
    Name = "CustomAnalyzers.RemoveWildcardsAnalyzer",
    Code = RemoveWildcardsAnalyzer,
}));
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToList();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToListAsync();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    .IncludeExplanations(out var explanations)
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToList();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/UsingCustomAnalyzer"
where search(EmployeeNotes, "*French*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### When using the Exact analyzer:
When using the default Exact analyzer in your index (which is [KeywordAnalyzer](../../indexes/using-analyzers#using-the-default-exact-analyzer)),  
then when querying the index, the wildcards in your search terms remain untouched.  
The terms are sent to the search engine exactly as produced by the analyzer.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstName_usingExactAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByFirstName_usingExactAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string FirstName { get; set; }
    }

    public Employees_ByFirstName_usingExactAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                FirstName = employee.FirstName
            };
        
        // Set the Exact analyzer for the index-field:
        // (The field will not be tokenized)
        Indexes.Add(x => x.FirstName, FieldIndexing.Exact);
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToListAsync();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    .IncludeExplanations(out var explanations)
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstName/usingExactAnalyzer"
where search(FirstName, "Mich*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



</LanguageContent>
<LanguageContent language="java">


When you need to do a more complex text searching, use the `search` method. This method allows you to pass a few search terms that will be used in the searching process for a particular field. Here is a sample code
that uses the `search` method to get users with the name *John* or *Adam*:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "John Adam")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where search(Name, 'John Adam')
`}
</CodeBlock>
</TabItem>
</Tabs>

Each of the search terms (separated by space character) will be checked independently. The result documents must match exactly one of the passed terms.

In the same way, you can also look for users that have some hobby:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Hobbies", "looking for someone who likes sport books computers")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where search(Name, 'looking for someone who likes sport books computers')
`}
</CodeBlock>
</TabItem>
</Tabs>

The results will return users that are interested in *sport*, *books* or *computers*.

## Multiple Fields

By using the `search` method, you are also able to look for multiple indexed fields. In order to search using both `name` and `hobbies` properties, you need to issue the following query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "Adam")
    .search("Hobbies", "sport")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where search(Name, 'Adam') or search(Hobbies, 'sport')
`}
</CodeBlock>
</TabItem>
</Tabs>

## Boosting

Indexing in RavenDB is built upon the Lucene engine that provides a boosting term mechanism. This feature introduces the relevance level of matching documents based on the terms found. 
Each search term can be associated with a boost factor that influences the final search results. The higher the boost factor, the more relevant the term will be. 
RavenDB also supports that, in order to improve your searching mechanism and provide the users with much more accurate results you can specify the boost argument. 

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Hobbies", "I love sport")
    .boost(10)
    .search("Hobbies", "but also like reading books")
    .boost(5)
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where boost(search(Hobbies, 'I love sport'), 10) or boost(search(Hobbies, 'but also like reading books'), 5)
`}
</CodeBlock>
</TabItem>
</Tabs>

This search will promote users who do sports before book readers and they will be placed at the top of the results list.

## Search Options

You can specify the logic of a search expression. It can be either:

* or,
* andAlso,
* not.

The following query:

<TabItem value="something-something" label="search_7_0">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Hobbies", "computers")
    .search("Name", "James")
    .whereEquals("Age", 20)
    .toList();
`}
</CodeBlock>
</TabItem>

will be translated into

<TabItem value="something" label="csharp">
<CodeBlock language="csharp">
{`from Users
where search(Hobbies, 'computers') or search(Name, 'James') and Age = 20
`}
</CodeBlock>
</TabItem>

You can also specify what exactly the query logic should be. The applied option will influence a query term where it was used. The query as follows:

<TabItem value="something-something" label="search_8_0">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "Adam")
    .andAlso()
    .search("Hobbies", "sport")
    .toList();
`}
</CodeBlock>
</TabItem>

will result in the following RQL query:

<TabItem value="something" label="csharp">
<CodeBlock language="csharp">
{`from Users
where search(Name, 'Adam') and search(Hobbies, 'sport')
`}
</CodeBlock>
</TabItem>

If you want to negate the term use `not`:

<TabItem value="something-something" label="search_9_0">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .not()
    .search("Name", "James")
    .toList();
`}
</CodeBlock>
</TabItem>

According to RQL syntax it will be transformed into the query:

<TabItem value="something" label="csharp">
<CodeBlock language="csharp">
{`from Users
where exists(Name) and not search(James, 'Adam')
`}
</CodeBlock>
</TabItem>

You can also combine search options:

<TabItem value="something-something" label="search_10_1">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "Adam")
    .andAlso()
    .not()
    .search("Hobbies", "sport")
    .toList();
`}
</CodeBlock>
</TabItem>

It will produce the following RQL query:

<TabItem value="something" label="csharp">
<CodeBlock language="csharp">
{`from Users
where search(Name, 'Adam') and (exists(Hobbies) and not search(Hobbies, 'sport'))
`}
</CodeBlock>
</TabItem>

## Using Wildcards

When the beginning or ending of a search term is unknown, wildcards can be used to add additional power to the searching feature. RavenDB supports both suffix and postfix wildcards.

### Example I - Using Postfix Wildcards

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "Jo* Ad*")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where search(Name, 'Jo* Ad*')
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Using Suffix and Postfix Wildcards

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class)
    .search("Name", "*oh* *da*")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from Users
where search(Name, '*oh* *da*')
`}
</CodeBlock>
</TabItem>
</Tabs>

<Admonition type="warning" title="Warning" id="warning" href="#warning">
RavenDB allows you to search by using such queries, but you have to be aware that **leading wildcards drastically slow down searches**.

Consider if you really need to find substrings. In most cases, looking for whole words is enough. There are also other alternatives for searching without expensive wildcard matches, e.g. indexing a reversed version of text field or creating a custom analyzer.
</Admonition>

## Static Indexes

All of the previous examples demonstrated searching capabilities by executing dynamic queries and were using auto indexes underneath. The same set of queries can be done when static indexes are used, and also those capabilities can be customized by changing the [analyzer](../using-analyzers) or setting up full text search on multiple fields.

### Example I - Basics

To be able to search you need to set `Indexing` to `Search` on a desired field.

<TabItem value="something" label="search_20_2">
<CodeBlock language="java">
{`public static class Users_ByName extends AbstractIndexCreationTask \{
    public Users_ByName() \{
        map = "docs.Users.Select(user => new \{" +
            "    Name = user.Name" +
            "\})";

        index("Name", FieldIndexing.SEARCH);
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class, Users_ByName.class)
    .search("Name", "John")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Users/ByName'
where search(Name, 'John')
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - FullTextSearch

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<User> users = session
    .query(User.class, Users_Search.class)
    .search("Query", "John")
    .toList();
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index 'Users/Search'
where search(Query, 'John')
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Indexing all fields for FTS

This indexing method is supported only when using **Lucene** as the indexing engine.

<TabItem value="something-something" label="index_all_fields">
<CodeBlock language="java">
{`public static class Products_ByAllValues extends AbstractIndexCreationTask \{
    public static class IndexEntry \{
        private String allValues;

        public String getAllValues() \{
            return allValues;
        \}

        public void setAllValues(String allValues) \{
            this.allValues = allValues;
        \}
    \}

    public Products_ByAllValues() \{
        map = "docs.Products.Select(product => new \{ " +
              // Use the 'AsJson' method to convert the document into a JSON-like structure
              // and call 'Select' to extract only the values of each property
              "    allValues = this.AsJson(product).Select(x => x.Value) " +
              "\})";

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.SEARCH' on index-field 'allValues'
        index("allValues", FieldIndexing.SEARCH);
        
        // Set the search engine type to Lucene:
        searchEngineType = SearchEngineType.LUCENE;
    \}
\}
`}
</CodeBlock>
</TabItem>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="java">
{`List<Product> results = session
    .query(Products_ByAllValues.IndexEntry.class, Products_ByAllValues.class)
    .search("allValues", "tofu")
    .ofType(Product.class)
    .toList();
    
// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(allValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>


</LanguageContent>
<LanguageContent language="python">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers#selecting-an-analyzer-for-a-field).    
* In this article:
  * [Indexing single field for FTS](../../indexes/querying/searching#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../indexes/querying/searching#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../indexes/querying/searching#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="something" label="index_1">
<CodeBlock language="python">
{`class Employees_ByNotes(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, employee_notes: str = None):
            self.employee_notes = employee_notes

    def __init__(self):
        super().__init__()
        # The 'Map' function defines the content of the index-fields
        self.map = "from employee in docs.Employees " "select new " "\{ " " employee_notes = employee.Notes[0]" "\}"

        # Configure the index-field for FTS:
        # Set 'FieldIndexing.Search' on index-field 'employee_notes'
        self._index("employee_notes", FieldIndexing.SEARCH)

        # Optionally: Set your choice of analyzer for the index-field:
        # Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        self._analyze("employee_notes", "WhitespaceAnalyzer")

        # Note:
        # If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the index
    .query_index_type(Employees_ByNotes, Employees_ByNotes.IndexEntry)
    # Call 'search':
    # pass the index field that was configured for FTS and the term to search for.
    .search("employee_notes", "French").of_type(Employee)
)
# * Results will contain all Employee documents that have 'French' in their 'Notes' field.

# * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
#   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="something" label="index_2">
<CodeBlock language="python">
{`class Employees_ByEmployeeData(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, employee_data: List = None):
            self.employee_data = employee_data

    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new \{"
            "  employee_data = "
            "  \{"
            # Multiple document-fields can be indexed
            # into the single index-field 'employee_data'
            "    employee.FirstName,"
            "    employee.LastName,"
            "    employee.Title,"
            "    employee.Notes"
            "  \}"
            "\}"
        )
        # Configure the index-field for FTS:
        # Set 'FieldIndexing.SEARCH' on index-field 'employee_data'
        self._index("employee_data", FieldIndexing.SEARCH)

        # Note:
        # Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the static-index
    .query_index_type(Employees_ByEmployeeData, Employees_ByEmployeeData.IndexEntry)
    .open_subclause()
    # A logical OR is applied between the following two search calls
    .search("employee_data", "Manager")
    # A logical AND is applied between the following two terms
    .search("employee_data", "French Spanish", operator=SearchOperator.AND)
    .close_subclause()
    .of_type(Employee)
)

# * Results will contain all Employee documents that have:
#   ('Manager' in any of the 4 document-fields that were indexed)
#   OR
#   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)

# * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method,
  which is available in the **C# LINQ string** that is assigned to the `map` property in the Python index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="Info">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="something" label="index_3">
<CodeBlock language="python">
{`class Products_ByAllValues(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, all_values: str = None):
            self.all_values = all_values

    def __init__(self):
        super().__init__()
        self.map = (
            "docs.Products.Select(product => new \{ "
            # Use the 'AsJson' method to convert the document into a JSON-like structure
            # and call 'Select' to extract only the values of each property
            "    all_values = this.AsJson(product).Select(x => x.Value) "
            "\})"
        )
        
        # Configure the index-field for FTS:
        # Set 'FieldIndexing.SEARCH' on index-field 'all_values'
        self._index("all_values", FieldIndexing.SEARCH)
        
        # Note:
        # Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
        
        # Set the search engine type to Lucene:
        self.search_engine_type = SearchEngineType.LUCENE
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_index_type(Products_ByAllValues, Products_ByAllValues.IndexEntry)
    .search("all_values", "tofu")
    .of_type(Product)
)

# * Results will contain all Product documents that have 'tofu'
#   in ANY of their fields.
#
# * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(all_values, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to the indexes [Boosting](../../indexes/boosting) article.  

  * Add a boost value to the queried terms **at query time**.  
    Refer to the [Boost search results](../../client-api/session/querying/text-search/boost-search-results) article.  




</LanguageContent>
<LanguageContent language="php">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers#selecting-an-analyzer-for-a-field).    
* In this article:
  * [Indexing single field for FTS](../../indexes/querying/searching#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../indexes/querying/searching#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../indexes/querying/searching#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="something" label="index_1">
<CodeBlock language="php">
{`// The IndexEntry class defines the index-fields
class Employees_ByNotes_IndexEntry
\{
    private ?string $employeeNotes = null;

    public function getEmployeeNotes(): ?string
    \{
        return $this->employeeNotes;
    \}

    public function setEmployeeNotes(?string $employeeNotes): void
    \{
        $this->employeeNotes = $employeeNotes;
    \}
\}
class Employees_ByNotes extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        // The 'Map' function defines the content of the index-fields
        $this->map =
            "from employee in docs.Employees " .
            "select new " .
            "\{ " .
               " employee_notes = employee.Notes[0]" .
            "\}";

        # Configure the index-field for FTS:
        # Set 'FieldIndexing.Search' on index-field 'employee_notes'
        $this->index("employee_notes", FieldIndexing::search());

        # Optionally: Set your choice of analyzer for the index-field:
        # Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        $this->analyze("employee_notes", "WhitespaceAnalyzer");

        # Note:
        # If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session
     // Query the index
    ->query(Employees_ByNotes_IndexEntry::class, Employees_ByNotes::class)
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    ->search("EmployeeNotes", "French")
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session->advanced()
     // Query the index
    ->documentQuery(Employees_ByNotes_IndexEntry::class, Employees_ByNotes::class)
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    ->search("EmployeeNotes", "French")
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="something" label="index_2">
<CodeBlock language="php">
{`class EmployeeData
\{
    private ?string $firstName = null;
    private ?string $lastName = null;
    private ?string $title = null;
    private ?string $notes = null;

    // ... getters and setters
\}

class EmployeeDataArray extends TypedArray
\{
    protected function __construct()
    \{
        parent::__construct(EmployeeData::class);
    \}
\}

class Employees_ByEmployeeData_IndexEntry
\{
    public ?EmployeeDataArray  $employeeData = null;
\}
class Employees_ByEmployeeData extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        $this->map =
            "from employee in docs.Employees " .
            "select new \{" .
            "  EmployeeData = " .
            "  \{" .
            # Multiple document-fields can be indexed
            # into the single index-field 'employee_data'
            "    employee.FirstName," .
            "    employee.LastName," .
            "    employee.Title," .
            "    employee.Notes" .
            "  \}" .
            "\}";

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeData'
        $this->index("EmployeeData", FieldIndexing::search());

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session
     // Query the static-index
    ->query(Employees_ByEmployeeData_IndexEntry::class, Employees_ByEmployeeData::class)
     // A logical OR is applied between the following two Search calls:
    ->search("EmployeeData", "Manager")
     // A logical AND is applied between the following two terms:
    ->search("EmployeeData", "French Spanish", SearchOperator::and())
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="documentQuery" label="documentQuery">
<CodeBlock language="php">
{`/** @var array<Employee> $employees */
$employees = $session->advanced()
     // Query the static-index
    ->documentQuery(Employees_ByEmployeeData_IndexEntry::class, Employees_ByEmployeeData::class)
    ->openSubclause()
     // A logical OR is applied between the following two Search calls:
    ->search("EmployeeData", "Manager")
     // A logical AND is applied between the following two terms:
    ->search("EmployeeData", "French Spanish", SearchOperator::and())
    ->closeSubclause()
    ->ofType(Employee::class)
    ->toList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method,
  which is available in the **C# LINQ string** that is assigned to the `map` property in the PHP index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="Info">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="something" label="index_3">
<CodeBlock language="php">
{`class Products_ByAllValues_IndexEntry
\{
    public ?string $allValues = null;
    public function getAllValues(): ?string
    \{
        return $this->allValues;
    \}
    public function setAllValues(?string $allValues): void
    \{
        $this->allValues = $allValues
    \}
\}

class Products_ByAllValues extends AbstractIndexCreationTask
\{
    public function __construct()
    \{
        parent::__construct();

        $this->map = "docs.Products.Select(product => new \{ " .
            # Use the 'AsJson' method to convert the document into a JSON-like structure
            # and call 'Select' to extract only the values of each property
            "    allValues = this.AsJson(product).Select(x => x.Value) " .
            "\})";

        # Configure the index-field for FTS:
        # Set 'FieldIndexing::search' on index-field 'allValues'
        $this->index("allValues", FieldIndexing::search());
        
        # Set the search engine type to Lucene:
        $this->setSearchEngineType(SearchEngineType::lucene());
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="php">
{`$results = $session->query(Products_ByAllValues_IndexEntry::class, Products_ByAllValues::class)
        ->search("allValues", "tofu")
        ->ofType(Product::class)
        ->toList();
        
// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(allValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* To prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to the indexes [Boosting](../../indexes/boosting) article.  

  * Add a boost value to the queried terms **at query time**.  
    Refer to the [Boost search results](../../client-api/session/querying/text-search/boost-search-results) article.  




</LanguageContent>
<LanguageContent language="nodejs">

<Admonition type="note" title="Note">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../indexes/using-analyzers#selecting-an-analyzer-for-a-field).
* In this article:
  * [Indexing single field for FTS](../../indexes/querying/searching#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../indexes/querying/searching#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../indexes/querying/searching#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../indexes/querying/searching#boosting-search-results)
  * [Searching with wildcards](../../indexes/querying/searching#searching-with-wildcards)
      * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching#when-usingoror)
      * [When using a custom analyzer](../../indexes/querying/searching#when-using-a-custom-analyzer)
      * [When using the Exact analyzer](../../indexes/querying/searching#when-using-the-exact-analyzer)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="something" label="index_1">
<CodeBlock language="nodejs">
{`class Employees_ByNotes extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            employeeNotes: e.Notes
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'employeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        this.analyze("employeeNotes", "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Using the `search` method has the advantage of using any of its functionalities,  
  such as using wildcards, searching for multiple terms, etc.  

* Refer to [Full-Text search with dynamic queries](../../client-api/session/querying/text-search/full-text-search) for all available **Search options**.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const employees = await session
     // Query the index
    .query({ indexName: "Employees/ByNotes" })
     // Call 'search':
     // pass the index field name that was configured for FTS and the term to search for.
    .search("employeeNotes", "French")
    .all();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(employeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="something" label="index_2">
<CodeBlock language="nodejs">
{`class Employees_ByEmployeeData extends AbstractJavaScriptIndexCreationTask \{

    constructor() \{
        super();

        // Define the index-fields 
        this.map("Employees", e => (\{
            // Multiple document-fields can be indexed
            // into the single index-field 'employeeData' 
            employeeData: [e.FirstName, e.LastName, e.Title, e.Notes]
        \}));

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'employeeNotes'
        this.index("employeeNotes", "Search");

        // Note:
        // Since no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const employees = await session
     // Query the static-index
    .query({ indexName: "Employees/ByEmployeeData" })
    .openSubclause()
     // A logical OR is applied between the following two Search calls:
    .search("employeeData", "Manager")
     // A logical AND is applied between the following two terms: 
    .search("employeeData", "French Spanish", "AND")
    .closeSubclause()
    .all();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(employeeData, "Manager") or search(employeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method, 
  which is available when using **a C# LINQ string** that is assigned to the `map` property in the Node.js index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="Info">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="something" label="index_6">
<CodeBlock language="nodejs">
{`// Extend the index class from 'AbstractCsharpIndexCreationTask':
class Products_ByAllValues extends AbstractCsharpIndexCreationTask \{
    constructor () \{
        super();

        // Using a C# LINQ string:  
        this.map = \`docs.Products.Select(product => new \{
                        AllValues = this.AsJson(product).Select(x => x.Value)
                    \})\`;

        // Configure the index-field for FTS:
        // Set 'Search' on index-field 'AllValues'
        this.index("AllValues", "Search");

        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.

        // Set the search engine type to Lucene:
        this.searchEngineType = "Lucene";
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`const products = await session
    .query({ indexName: "Products/ByAllValues" })
    .search("AllValues", "tofu")
    .all();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(AllValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../indexes/boosting).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../client-api/session/querying/text-search/boost-search-results).



## Searching with wildcards

* When making a full-text search with wildcards in the search terms,
  the presence of wildcards (`*`) in the terms sent to the search engine is determined by the transformations applied by the
  [analyzer](../../indexes/using-analyzers) used in the index.

* Note the different behavior in the following cases, as described below:
  * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../indexes/querying/searching#when-usingoror)
  * [When using a custom analyzer](../../indexes/querying/searching#when-using-a-custom-analyzer)
  * [When using the Exact analyzer](../../indexes/querying/searching#when-using-the-exact-analyzer)

* When using [Corax](../../indexes/search-engine/corax) as the search engine,  
  this behavior will only apply to indexes that are newly created or have been reset.
<Admonition type="note" title="Note">

##### When using&nbsp;`RavenStandardAnalyzer`&nbsp;or`StandardAnalyzer`&nbsp;or&nbsp;`NGramAnalyzer`:
Usually, the same analyzer used to tokenize field content at **indexing time** is also used to process the terms provided in the **full-text search query**
before they are sent to the search engine to retrieve matching documents.

**However, in the following cases**:

* When making a [dynamic search query](../../client-api/session/querying/text-search/full-text-search)
* or when querying a static index that uses the default [RavenStandardAnalyzer](../../indexes/using-analyzers#using-the-default-search-analyzer)
* or when querying a static index that uses the [StandardAnalyzer](../../indexes/using-analyzers#analyzers-that-remove-common-stop-words)
* or when querying a static index that uses the [NGramAnalyzer](../../indexes/using-analyzers#analyzers-that-tokenize-according-to-the-defined-number-of-characters)

the queried terms in the _search_ method are processed with the [LowerCaseKeywordAnalyzer](../../indexes/using-analyzers#using-the-default-analyzer)  
before being sent to the search engine.

This analyzer does Not remove the `*`, so the terms are sent with `*`, as provided in the search terms.  
For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="nodejs">
{`class Employees_ByNotes_usingDefaultAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        // Define the index-fields 
        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Since no analyzer is explicitly set
        // then the default 'RavenStandardAnalyzer' will be used at indexing time.

        // However, when making a search query with wildcards,
        // the 'LowerCaseKeywordAnalyzer' will be used to process the search terms
        // prior to sending them to the search engine.
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingDefaultAnalyzer" })
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the search method:
    .search("employeeNotes", "*rench")
    .all();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "employeeNotes:*rench";

assert.ok(explanation.includes(expectedVal), 
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/usingDefaultAnalyzer"
where search(EmployeeNotes, "*rench")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### When using a custom analyzer:
* When setting a [custom analyzer](../../indexes/using-analyzers#creating-custom-analyzers) in your index to tokenize field content,
  then when querying the index, the search terms in the query will be processed according to the custom analyzer's logic.

* The `*` will remain in the terms if the custom analyzer allows it.
  It is the userâ€™s responsibility to ensure that wildcards are not removed by the custom analyzer if they should be included in the query.

* Note:  
  An exception to the above is when the wildcard is used as a suffix in the search term (e.g. `Fren*`).  
  In this case the wildcard will be included in the query regardless of the analyzer's logic.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="nodejs">
{`class Employees_ByNotes_usingCustomAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            employeeNotes: e.Notes
        }));

        // Configure the index-field for FTS:
        this.index("employeeNotes", "Search");

        // Set a custom analyzer for the index-field:
        this.analyze("employeeNotes", "RemoveWildcardsAnalyzer");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Custom_analyzer" label="Custom_analyzer">
<CodeBlock language="nodejs">
{`// The custom analyzer:
// ====================

const removeWildcardsanalyzer = \`
    using System.IO;
    using Lucene.Net.Analysis; 
    using Lucene.Net.Analysis.Standard;
    namespace CustomAnalyzers
    {
        public class RemoveWildcardsAnalyzer : StandardAnalyzer
        {
            public RemoveWildcardsAnalyzer() : base(Lucene.Net.Util.Version.LUCENE_30)
            {
            }
    
            public override TokenStream TokenStream(string fieldName, System.IO.TextReader reader)
            {
                // Read input stream and remove wildcards (*)
                string text = reader.ReadToEnd();
                string processedText = RemoveWildcards(text);
                StringReader newReader = new StringReader(processedText);
                
                return base.TokenStream(fieldName, newReader);
            }
    
            private string RemoveWildcards(string input)
            {
                // Replace wildcard characters with an empty string
                return input.Replace("*", "");
            }
        }
    }\`;

// Deploying the custom analyzer:
// ==============================

const analyzerDefinition = {
    name: "RemoveWildcardsAnalyzer",
    code: RemoveWildcardsAnalyzer
};

await documentStore.maintenance.send(new PutAnalyzersOperation(analyzerDefinition));
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByNotes/usingCustomAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with wildcards to the Search method:
    .search("employeeNotes", "*French*")
    .all();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
const explanation = explanations.explanations[employees[0].id][0];

const expectedVal = "employeeNotes:french";
assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);

const notExpectedVal = "employeeNotes:*french";
assert.ok(!explanation.includes(notExpectedVal),
    \`'$\{explanation\}' does not contain '$\{notExpectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/UsingCustomAnalyzer"
where search(EmployeeNotes, "*French*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="Note">

##### When using the Exact analyzer:
When using the default Exact analyzer in your index (which is [KeywordAnalyzer](../../indexes/using-analyzers#using-the-default-exact-analyzer)),  
then when querying the index, the wildcards in your search terms remain untouched.  
The terms are sent to the search engine exactly as produced by the analyzer.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="nodejs">
{`class Employees_ByFirstName_usingExactAnalyzer extends AbstractJavaScriptIndexCreationTask {

    constructor() {
        super();

        this.map("Employees", e => ({
            firstName: e.FirstName
        }));

        // Set the Exact analyzer for the index-field:
        // (The field will not be tokenized)
        this.index("firstName", "Exact");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="nodejs">
{`let explanations;

const employees = await session
    .query({ indexName: "Employees/ByFirstName/usingExactAnalyzer" })
    .includeExplanations(e => explanations = e)
     // Provide a term with a wildcard to the Search method:
    .search("firstName", "Mich*")
    .all();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

const explanation = explanations.explanations[employees[0].id][0];
const expectedVal = "firstName:Mich*";

assert.ok(explanation.includes(expectedVal),
    \`'$\{explanation\}' does not contain '$\{expectedVal\}.'\`);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstName/usingExactAnalyzer"
where search(FirstName, "Mich*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



</LanguageContent>