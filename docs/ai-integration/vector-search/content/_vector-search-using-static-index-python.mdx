import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Admonition type="note" title="">

* This article explains how to perform a **vector search** using a **static index**.  
  **Prior to this article**, it is recommended to get familiar with the [Vector search using a dynamic query](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx) article.

* A static index allows you to define a **vector index-field**, enabling you to execute vector searches
  while leveraging the advantages of RavenDB's [indexes](../../../indexes/what-are-indexes.mdx).

* The vector search feature is only supported by indexes that use the [Corax search engine](../../../indexes/search-engine/corax.mdx).

* In this article:
    * [Indexing a vector field - Overview](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-a-vector-field---overview)
       * [Defining a vector field in a static index](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#defining-a-vector-field-in-a-static-index)
       * [Parameters defined at index definition](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#parameters-defined-at-index-definition)
       * [Behavior during indexing](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#behavior-during-indexing)
       * [Parameters used at query time](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#parameters-used-at-query-time)
       * [Behavior when documents are deleted](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#vector-behavior-when-documents-are-deleted)
    * [Indexing vector data - TEXT](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---text)
      * [Indexing raw text](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-raw-text)
      * [Indexing pre-made text-embeddings generated by tasks](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings-generated-by-tasks)
    * [Indexing vector data - NUMERICAL](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---numerical)
      * [Indexing numerical data and querying using numeric input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-numeric-input)
      * [Indexing numerical data and querying using text input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-text-input)
    * [Indexing multiple field types](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-multiple-field-types)
    * [Querying the static index for similar documents](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#querying-the-static-index-for-similar-documents)
    * [Configure the vector field in Studio](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#configure-the-vector-field-in-studio)

</Admonition>

## Indexing a vector field - Overview

<Admonition type="note" title="">

#### Defining a vector field in a static index

To define a vector index-field in your static-index definition:  

* **From the Client API**:  
 
    **`LoadVector()`**:  
    When indexing **pre-made text-embeddings** generated by RavenDB's [Embeddings generation tasks](../../../ai-integration/generating-embeddings/overview.mdx),  
    use the `LoadVector()` method in your index definition.  
    An example is available in [Indexing pre-made text-embeddings](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings-generated-by-tasks).
   
    **`CreateVector()`**:  
    When indexing **your own data** (textual or numerical) that was not generated by these tasks,  
    use the `CreateVector()` method in your index definition.  
    An example is available in [Indexing raw text](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-raw-text).  

* **From Studio**:  
  See [Define a vector field in Studio](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#configure-the-vector-field-in-studio).  

The **source data types** that can be used for vector search are detailed in [Data types for vector search](../../../ai-integration/vector-search/data-types-for-vector-search.mdx).

</Admonition>

<Admonition type="note" title="">

#### Parameters defined at index definition  

The following params can be defined for the vector index-field in the index definition:  

**Source embedding type** -   
RavenDB supports performing vector search on TEXTUAL values or NUMERICAL arrays.  
This param specifies the embedding format of the source data to be indexed.  
Options include `Text`, `Single`, `Int8`, or `Binary`.  

**Destination embedding type** -   
Specify the quantization format for the embeddings that will be generated.  
Read more about quantization in [Quantization options](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#quantization-options).

**Dimensions** -   
For numerical input only - define the size of the array from your source document.  

* If this param is Not provided -  
  the size will be determined by the first document indexed and will apply to all subsequent documents.

* Ensure the dimensionality of these numerical arrays (i.e., their length) is consistent across all source documents for the indexed field.
  An index error will occur if a source document has a different dimension for the indexed field.

**Number of edges** -  
Specify the number of edges that will be created for a vector during indexing.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfEdges](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofedges).

**Number of candidates for indexing time** -   
The  number of candidates (potential neighboring vectors) that RavenDB evaluates during vector indexing.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfCandidatesForIndexing](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofcandidatesforindexing).   
(Note, this param differs from the number of candidates for query time).

</Admonition>

<Admonition type="note" title="">

#### Behavior during indexing

* **Raw textual input**:  
  When indexing raw textual input from your documents, RavenDB generates embedding vectors using the built-in  
  [bge-micro-v2](https://huggingface.co/TaylorAI/bge-micro-v2) sentence-transformer model, which are then indexed.

* **Pre-made text-embeddings input**:  
  When indexing embeddings that are pre-generated from your documents' raw text by RavenDB's  
  [Embeddings generation tasks](../../../ai-integration/generating-embeddings/overview.mdx),
  RavenDB indexes them without additional transformation, unless quantization is applied.  
 
* **Raw numerical input**:  
  When indexing pre-made numerical arrays that are already in vector format but were Not generated by these tasks,  
  such as numerical arrays you created externally, RavenDB indexes them without additional transformation,  
  unless quantization is applied.  

The embeddings are indexed on the server using the [HNSW algorithm](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world).  
This algorithm organizes embeddings into a high-dimensional graph structure,  
enabling efficient retrieval of Approximate Nearest Neighbors (ANN) during queries.

</Admonition>

<Admonition type="note" title="">

#### Parameters used at query time

**Minimum similarity** -  
You can specify the minimum similarity to use when searching for related vectors. Can be a value between `0.0` and `1.0`.  
A value closer to `1.0` requires higher similarity between vectors, while a value closer to `0.0` allows for less similarity.  
If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultMinimumSimilarity](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultminimumsimilarity).

**Number of candidates at query time** -  
You can specify the maximum number of vectors that RavenDB will return from a graph search.  
The number of the resulting documents that correspond to these vectors may be:  

  * lower than the number of candidates - when multiple vectors originated from the same document.  
   
  * higher than the number of candidates - when the same vector is shared between multiple documents.

If not specified, the default value is taken from the following configuration key: [Indexing.Corax.VectorSearch.DefaultNumberOfCandidatesForQuerying](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchdefaultnumberofcandidatesforquerying).

**Search method** -  
You can specify the search method at query time:  

  *  _Approximate Nearest-Neighbor search_ (Default):  
     Search for related vectors in an approximate manner, providing faster results.

  *  _Exact search_:  
     Perform a thorough scan of the vectors to find the actual closest vectors,  
     offering better accuracy but at a higher computational cost.

**To ensure consistent comparisons** -  
the search term is transformed into an embedding vector using the same method as the vector index-field.  

**Search results** -  
The server will search for the most similar vectors in the indexed vector space, taking into account all the parameters described.
The documents that correspond to the resulting vectors are then returned to the client.

By default, the resulting documents will be ordered by their score.
You can modify this behavior using the [Indexing.Corax.VectorSearch.OrderByScoreAutomatically](../../../server/configuration/indexing-configuration.mdx#indexingcoraxvectorsearchorderbyscoreautomatically) configuration key.  
In addition, you can apply any of the 'order by' methods to your query, as explained in [sort query results](../../../client-api/session/querying/sort-query-results.mdx).

</Admonition>

<Admonition type="note" title="">

#### Vector behavior when documents are deleted  

* RavenDB's implementation of the HNSW graph is append-only.  

* When all documents associated with a specific vector are deleted, the vector itself is Not physically removed but is soft-deleted.
  This means the vector is marked as deleted and will no longer appear in query results.  
  Currently, compaction is not supported.

</Admonition>

---

## Indexing vector data - TEXT

### Indexing raw text

The index in this example indexes data from raw text.  
For an index that indexes pre-made text-embeddings see [this example below](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-pre-made-text-embeddings-generated-by-tasks).
 
The following index defines a **vector field** named `vector_from_text`.  
It indexes embeddings generated from the raw textual data in the `Name` field of all _Product_ documents.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Products_ByVector_Text(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateVector' to create a VECTOR FIELD
        # Pass the document field containing the text from which the embeddings will be generated
        self.map = "from p in docs.Products select new { vector_from_text = CreateVector(p.Name) }"

        # Customize the vector field using _vector
        self._vector(
            "vector_from_text",
            VectorOptions(
                VectorEmbeddingType.TEXT,
                VectorEmbeddingType.SINGLE,
                number_of_edges=20,
                number_of_candidates_for_indexing=20,
            ),
        )

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Products_ByVector_Text_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            "map('Products', function (p) { return { vector_from_text: createVector(p.Name) }; })"
        }

        self.fields = {
            "vector_from_text" : IndexFieldOptions(
                vector=VectorOptions(VectorEmbeddingType.TEXT, VectorEmbeddingType.SINGLE, number_of_edges=20, number_of_candidates_for_indexing=20)
            )
        }

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="index_definition" label="index_definition">
```python
index_definition = IndexDefinition(
    name="Products/ByVector/Text",
    maps={"from p in docs.Products select new { vector_from_text = CreateVector(p.Name) }"},
    fields={
        "vector_from_text": IndexFieldOptions(
            vector=VectorOptions(
                source_embedding_type=VectorEmbeddingType.TEXT,
                destination_embedding_type=VectorEmbeddingType.SINGLE,
                number_of_edges=20,
                number_of_candidates_for_indexing=20
            )
        )
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"}
)

store.maintenance.send(PutIndexesOperation(index_definition))
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Product_ documents where the `Name` field is similar to the search term `"italian food"`.

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
similar_products = list(
        session.advanced.raw_query(
            (
                "from index 'Products/ByVector/Text' "
                # Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
                "where exact(vector.search(vector_from_text, $searchTerm, 0.82, 20))"
            ),
            object_type=Product,
        )
        .add_parameter("searchTerm", "italian food")
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Products/ByVector/Text"
// Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
where exact(vector.search(vector_from_text, $searchTerm, 0.82, 20))
{ "searchTerm" : "italian food" }
`}
```
</TabItem>
</Tabs>

### Indexing pre-made text-embeddings generated by tasks

The index in this example defines a **vector field** named `vector_from_text_embeddings`.  
It indexes pre-made text-embeddings that were generated by this
[embedding generation task](../../../ai-integration/generating-embeddings/embeddings-generation-task.mdx#configuring-an-embeddings-generation-task---from-the-studio).
 
<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Categories_ByPreMadeTextEmbeddings(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()

        # Call 'LoadVector' to create a VECTOR FIELD. Pass:
        # * The document field name to be indexed (as a string)
        # * The identifier of the task that generated the embeddings for the 'Name' field
        self.map = 'from c in docs.Categories select new { vector_from_text_embeddings = LoadVector("Name", "id-for-task-open-ai") }'

        self._vector(
            "vector_from_text_embeddings",
            VectorOptions(
                # Vector options can be customized in the same way as the above index example
            ),
        )

        # The index MUST use the Corax search engine
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Categories_ByPreMadeTextEmbeddings_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            'map("Categories", function (c) { return { vector_from_text_embeddings: loadVector("Name", "id-for-task-open-ai") }; })'
        }

        self.fields = {
            "vector_from_text_embeddings": IndexFieldOptions(
                vector=VectorOptions(
                    # Vector options can be customized in the same way as the above index example
                )
            )
        }

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```python
index_definition = IndexDefinition(
    name="Categories/ByPreMadeTextEmbeddings",
    maps={
        'from c in docs.Categories select new { vector_from_text_embeddings = LoadVector("Name", "id-for-task-open-ai") }'
    },
    fields={
        "vector_from_text_embeddings": IndexFieldOptions(
            vector=VectorOptions(
                # Vector options can be customized in the same way as the above index example
            )
        )
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"},
)
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Category_ documents where the `Name` field is similar to the search term `"candy"`.

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
similar_categories = list(
        session.advanced.raw_query(
            (
                "from index 'Categories/ByPreMadeTextEmbeddings'"
                # Optionally, wrap the 'vector.search' query with 'exact' to perform an exact search
                "where exact(vector.search(vector_from_text_embeddings, $searchTerm, 0.75, 20))"
            ),
            object_type=Category,
        )
        .add_parameter("searchTerm", "candy")
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Categories/ByPreMadeTextEmbeddings"
// Optionally, wrap the 'vector.search' query with 'exact()' to perform an exact search
where exact(vector.search(vector_from_text_embeddings, $p0, 0.75, 20))
{ "p0": "candy" }
`}
```
</TabItem>
</Tabs>

---

## Indexing vector data - NUMERICAL

<Admonition type="note" title="">

* RavenDB’s [Embedding generation tasks](../../../ai-integration/generating-embeddings/overview.mdx) are typically used to generate vector embeddings from TEXTUAL data stored in your documents. 
  These embeddings are then stored in [dedicated collections](../../../ai-integration/generating-embeddings/embedding-collections.mdx).

* However, you are not limited to using these built-in tasks.
  You can generate your own NUMERICAL embeddings - from any source (e.g., text, image, audio, etc.) - using a suitable multimodal model, and store them:
    * as numerical arrays in your documents’ properties, or
    * as attachments associated with your documents.

* This numerical data can be indexed in a vector field in a static-index.  
  Once indexed, you can query the vector field using either of the following:

  * **Query using a numerical embedding (direct vector)**:  
    You provide a numerical array as the search term, and RavenDB compares it directly against the indexed embeddings.
    See [Indexing numerical data and querying using numeric input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-numeric-input).  

  * **Query using a text input**:   
    You provide a text string as the search term and specify an existing [Embedding generation task](../../../ai-integration/generating-embeddings/overview.mdx) that will convert this text into a vector embedding.
    This will work only if:  
    * the vector field you're querying contains numerical embeddings that were created using the **same model** as the one configured in the specified task, and
    * that task exists in your database (i.e., its identifier is still available).

    In this case, RavenDB uses the task to transform the search term into an embedding, then compares it to the vector data that you had previously indexed yourself.
    To improve performance, the generated embedding is cached, so repeated queries with the same search term don’t require re-computation.
    
    This hybrid approach allows you to index custom embeddings (e.g., externally generated image vectors)
    while still benefiting from RavenDB’s ability to perform semantic text search, as long as the same model was used for both.  
    See [Indexing numerical data and querying using text input](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-numerical-data-and-querying-using-text-input).  

* <Admonition type="info" title="">
  The examples in this section use the [sample data provided in the dynamic query article](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#sample-data).
  </Admonition>

</Admonition>

### Indexing numerical data and querying using numeric input

The following index defines a vector field named `vector_from_single`.  
It indexes embeddings generated from the numerical data in the `tags_embedded_as_single` field of all _Movie_ documents.  
The raw numerical data in the source documents is in **32-bit floating-point format**.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Movies_ByVector_Single(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateVector' to create a VECTOR FIELD.
        # Pass the document field containing the array of floats (32-bit floating-point values)
        # from which the embeddings will be generated
        self.map = "from m in docs.Movies select new { vector_from_single = CreateVector(m.tags_embedded_as_single) }"
    
        # Customize the vector field using _vector
        self._vector("vector_from_single", VectorOptions(
            # Define the source embedding type
            source_embedding_type=VectorEmbeddingType.SINGLE,
            
            # Define the quantization for the destination embedding 
            destination_embedding_type=VectorEmbeddingType.SINGLE,
            
            # It is recommended to configure the number of dimensions 
            # which is the size of the arrays that will be indexed.
            dimensions=2,
            
            # Optionally, set the number of edges and candidates
            number_of_edges=20,
            number_of_candidates_for_indexing=20,
        ))
        
        # The index MUST use the Corax search engine
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Movies_ByVector_Single_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            "map('Movies', function (m) { return { vector_from_single: createVector(m.tags_embedded_as_single) }; })"
        }
        self.fields = {
            "vector_from_single": IndexFieldOptions(
                vector=VectorOptions(
                    source_embedding_type=VectorEmbeddingType.SINGLE,
                    destination_embedding_type=VectorEmbeddingType.SINGLE,
                    dimensions=2,
                    number_of_edges=20,
                    number_of_candidates_for_indexing=20,
                )
            )
        }

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```python
index_definition = IndexDefinition(
    name="Movies/ByVector/Single",
    maps={"from m in docs.Movies select new { vector_from_single = CreateVector(m.tags_embedded_as_single) }"},
    fields={
        "vector_from_single": IndexFieldOptions(
            vector=VectorOptions(
                source_embedding_type=VectorEmbeddingType.SINGLE,
                destination_embedding_type=VectorEmbeddingType.SINGLE,
                dimensions=2,
                number_of_edges=20,
                number_of_candidates_for_indexing=20,
            )
        )
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"},
)

store.maintenance.send(PutIndexesOperation(index_definition))
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
(Provide a vector as the `vector.search` search term)

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
similar_movies = list(
        session.advanced.raw_query(
            "from index 'Movies/ByVector/Single' where vector.search(vector_from_single, $queryVector)",
            object_type=Movie,
        )
        .add_parameter("queryVector", [6.599999904632568, 7.699999809265137])
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Movies/ByVector/Single"
where vector.search(vector_from_single, $queryVector)
{ "queryVector" : { "@vector" : [6.599999904632568, 7.699999809265137] }}
`}
```
</TabItem>
</Tabs>

The following index defines a vector field named `vector_from_int8_arrays`.  
It indexes embeddings generated from the numerical arrays in the `tags_embedded_as_int8` field of all _Movie_ documents.  
The raw numerical data in the source documents is in **Int8 (8-bit integers) format**. 

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Movies_ByVector_Int8(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateVector' to create a VECTOR FIELD.
        # Pass the document field containing the arrays (8-bit signed values)
        # from which the embeddings will be generated
        self.map = "from m in docs.Movies select new { vector_from_int8_arrays = CreateVector(m.tags_embedded_as_int8) }"

        # Customize the vector field using _vector
        self._vector(
            "vector_from_int8_arrays",
            VectorOptions(
                # Define the source embedding type
                source_embedding_type=VectorEmbeddingType.INT8,

                # Define the quantization for the destination embedding
                destination_embedding_type=VectorEmbeddingType.INT8,

                # It is recommended to configure the number of dimensions
                # which is the size of the arrays that will be indexed.
                dimensions=2,

                # Optionally, set the number of edges and candidates
                number_of_edges=20,
                number_of_candidates_for_indexing=20,
            ),
        )

        # The index MUST use the Corax search engine
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Movies_ByVector_Int8_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            "map('Movies', function (m) { return { vector_from_int8_arrays: createVector(m.tags_embedded_as_int8) }; })"
        }
        self.fields = {
            "vector_from_int8_arrays": IndexFieldOptions(
                vector=VectorOptions(
                    source_embedding_type=VectorEmbeddingType.INT8,
                    destination_embedding_type=VectorEmbeddingType.INT8,
                    dimensions=2,
                    number_of_edges=20,
                    number_of_candidates_for_indexing=20,
                )
            )
        }

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```python
index_definition = IndexDefinition(
    name="Movies/ByVector/Int8",
    maps={"from m in docs.Movies select new { vector_from_int8_arrays = CreateVector(m.tags_embedded_as_int8) }"},
    fields={
        "vector_from_int8_arrays": IndexFieldOptions(
            vector=VectorOptions(
                source_embedding_type=VectorEmbeddingType.INT8,
                destination_embedding_type=VectorEmbeddingType.INT8,
                dimensions=2,
                number_of_edges=20,
                number_of_candidates_for_indexing=20,
            )
        )
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"},
)

store.maintenance.send(PutIndexesOperation(index_definition))
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
(Provide a vector as the `vector.search` search term)

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
similar_movies = list(
        session.advanced.raw_query(
            "from index 'Movies/ByVector/Int8' where vector.search(vector_from_int8_arrays, $queryVector)",
            object_type=Movie,
        )
        .add_parameter("queryVector", VectorQuantizer.to_int8([0.1, 0.2]))
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Movies/ByVector/Int8"
where vector.search(vector_from_int8_arrays, $queryVector)
{ "queryVector" : [64, 127, -51, -52, 76, 62] }
`}
```
</TabItem>
</Tabs>

### Indexing numerical data and querying using text input

The following index defines a vector field named `vector_from_photo`.  
It indexes embeddings generated from the numerical data in the `movie_photo_embedding` field of all _Movie_ documents.  

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Movies_ByVectorFromPhoto(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        # Call 'CreateVector' to create a VECTOR FIELD.
        # Pass the document field containing the array from which the embeddings will be generated
        self.map = "from m in docs.Movies select new { vector_from_photo = CreateVector(m.movie_photo_embedding) }"

        # Customize the vector field using _vector
        self._vector(
            "vector_from_photo",
            VectorOptions(
                source_embedding_type=VectorEmbeddingType.SINGLE,
                destination_embedding_type=VectorEmbeddingType.SINGLE,
                # Dimensions should match the embedding size, 6 is only for our simple example...
                dimensions=6,
            ),
        )

        # The index MUST use the Corax search engine
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Movies_ByVectorFromPhoto_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            "map('Movies', function (m) { return { vector_from_photo: createVector(m.movie_photo_embedding) }; })"
        }
        self.fields = {
            "vector_from_photo": IndexFieldOptions(
                vector=VectorOptions(
                    source_embedding_type=VectorEmbeddingType.SINGLE,
                    destination_embedding_type=VectorEmbeddingType.SINGLE,
                    dimensions=6, # using 6 only for this simple example
                )
            )
        }

        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```python
index_definition = IndexDefinition(
    name="Movies/ByVector/FromPhoto",
    maps={"from m in docs.Movies select new { vector_from_photo = CreateVector(m.movie_photo_embedding) }"},
    fields={
        "vector_from_photo": IndexFieldOptions(
            vector=VectorOptions(
                source_embedding_type=VectorEmbeddingType.SINGLE,
                destination_embedding_type=VectorEmbeddingType.SINGLE,
                dimensions=6, # using 6 only for this simple example
            )
        )
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"},
)

store.maintenance.send(PutIndexesOperation(index_definition))
```
</TabItem>
</Tabs>

Execute a vector search using the index:  

  * To convert the text into an embedding, pass a textual search term and the task ID to the `embedding.text()` call in the `vector.search` clause.
  
  * The query is only meaningful if the vector field being searched contains numerical embeddings  
    generated using the same model as the one configured in the specified task.
  
  * If the specified task ID is not found, RavenDB will throw an `InvalidQueryException`.  
    To avoid this error, you can verify that the specified embeddings generation task exists before issuing the query.  
    See [Get embeddings generation task details](../../../ai-integration/generating-embeddings/overview.mdx#get-embeddings-generation-task-details)
    to learn how to check which tasks are defined and what their identifiers are.

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
similar_movies = list(
        session.advanced.raw_query(
            "from index 'Movies/ByVectorFromPhoto' where vector.search(vector_from_photo, embedding.text($searchTerm, ai.task($embeddingTaskId)), 0.85, null)", Movie
        )
        .add_parameter("searchTerm", "NASA")
        .add_parameter("embeddingTaskId", "id-for-task-open-ai")
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
from index 'Movies/ByVectorFromPhoto'
where vector.search(vector_from_photo, embedding.text($searchTerm, ai.task($embeddingTaskId)), 0.85, null)
{ "searchTerm" : "NASA", "embeddingTaskId" : "id-of-embedding-generation-task" }
```
</TabItem>
</Tabs>

---

## Indexing multiple field types

An index can define multiple types of index-fields. In this example, the index includes:  
A _'regular'_ field, a _'vector'_ field, and a field configured for [full-text search](../../../indexes/querying/searching.mdx).  
This allows you to query across all fields using various predicates.

<Tabs groupId='languageSyntax'>
<TabItem value="AbstractIndexCreationTask" label="AbstractIndexCreationTask">
```python
class Products_ByMultipleFields(AbstractIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.map = (
            "from product in docs.Products "
            "select new "
            "{"
            "   price_per_unit = product.PricePerUnit,"
            "   name = product.Name,"
            "   vector_from_text = CreateVector(product.Name)"
            "}"
        )

        # Configure the index-field 'Name' for FTS:
        self._index("name", FieldIndexing.SEARCH)

        # Note:
        # Default values will be used for the VECTOR FIELD if not customized here.

        # The index MUST use the Corax search engine
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="JS_index" label="JS_index">
```python
class Products_ByMultipleFields_JS(AbstractJavaScriptIndexCreationTask):
    def __init__(self):
        super().__init__()
        self.maps = {
            "map('Products', function (p) {"
            "   return {"
            "       price_per_unit: p.PricePerUnit, "
            "       name: p.Name, "
            "       vector_from_text: createVector(p.Name) "
            "   };"
            "})"
        }
        
        self.fields = {
            "name": IndexFieldOptions(indexing=FieldIndexing.SEARCH),
        }
        
        self.search_engine_type = SearchEngineType.CORAX
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```python
index_definition = IndexDefinition(
    name="Products/ByMultipleFields",
    maps={
        "from product in docs.Products "
        "select new "
        "{"
        "   price_per_unit = product.PricePerUnit,"
        "   name = product.Name,"
        "   vector_from_text = CreateVector(product.Name)"
        "}"
    },
    fields={
        "name": IndexFieldOptions(indexing=FieldIndexing.SEARCH),
    },
    configuration={"Indexing.Static.SearchEngineType": "Corax"},
)

store.maintenance.send(PutIndexesOperation(index_definition))
```
</TabItem>
</Tabs>

Execute a query that combines predicates across all index-field types:  

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
results = list(
        session.advanced.raw_query(
            "from index 'Products/ByMultipleFields' where price_per_unit > $minPrice or search(name, $searchTerm1) or vector.search(vector_from_text, $searchTerm2, 0.8)",
            object_type=Product,
        )
        .add_parameter("minPrice", 200)
        .add_parameter("searchTerm1", "Alice")
        .add_parameter("searchTerm2", "italian")
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Products/ByMultipleFields"
where price_per_unit > $minPrice
or search(name, $searchTerm1)
or vector.search(vector_from_text, $searchTerm2, 0.8)
{ "minPrice" : 200, "searchTerm1" : "Alice", "searchTerm2": "italian food" }
`}
```
</TabItem>
</Tabs>

* Note:  
You can also combine **multiple vector search statements** in a single query using logical operators.  
An example is available in:
[Combining multiple vector searches in the same query](../../ai-integration/vector-search/vector-search-using-dynamic-query#combining-multiple-vector-searches-in-the-same-query).


---

## Querying the static index for similar documents

* Similar to [querying for similar documents using a dynamic query](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#dynamic-vector-search---querying-for-similar-documents),  
  you can **query a static-index for similar documents** by specifying a document ID in the vector search.

* The following example queries the static-index defined in [this example](../../../ai-integration/vector-search/vector-search-using-static-index.mdx#indexing-vector-data---text) above.
  The document for which we want to find similar documents is specified by the document ID passed to the `forDoc` method.

* RavenDB retrieves the embedding that was indexed for the queried field in the specified document and uses it as the query vector for the similarity comparison.

* The results will include documents whose indexed embeddings are most similar to the one stored in the referenced document’s index-entry.

<Tabs groupId='languageSyntax'>
<TabItem value="raw_query" label="raw_query">
```python
results = list(
        session.advanced.raw_query(
            # Pass a document ID to the 'forDoc' method to find similar documents
            "from index 'Products/ByVector/Text' where vector.search(vector_from_text, embedding.forDoc($documentID), 0.82)",
            object_type=Product,
        )
        .add_parameter("documentID", "Products/7-A")
        .wait_for_non_stale_results()
    )
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
{`from index "Products/ByVector/Text"
// Pass a document ID to the 'forDoc' method to find similar documents
where vector.search(vector_from_text, embedding.forDoc($documentID), 0.82)
{"documentID" : "Products/7-A"}
`}
```
</TabItem>
</Tabs>

Running the above example on RavenDB’s sample data returns the following documents that have similar content in their _Name_ field:
(Note: the results include the referenced document itself, _Products/7-A_)

```
{`// ID: products/7-A  ... Name: "Uncle Bob's Organic Dried Pears"
// ID: products/51-A ... Name: "Manjimup Dried Apples"
// ID: products/6-A  ... Name: "Grandma's Boysenberry Spread"
`}
```

---

## Configure the vector field in Studio

  ![Add vector field](../assets/add-vector-field-1.png)

  ![Customize vector field](../assets/add-vector-field-2.png)

1. **Vector field name**  
   Enter the name of the vector field to customize.
2. **Configure Vector Field**  
   Click this button to customize the field.
3. **Dimensions**  
   For numerical input only - define the size of the array from your source document.
4. **Edges**  
   The number of edges that will be created for a vector during indexing.
5. **Source embedding type**  
   The format of the source embeddings (Text, Single, Int8, or Binary).
6. **Candidates for indexing**  
   The number of candidates (potential neighboring vectors) that RavenDB evaluates during vector indexing.
7. **Destination embedding type**  
   The quantization format for the embeddings that will be generated (Text, Single, Int8, or Binary).
