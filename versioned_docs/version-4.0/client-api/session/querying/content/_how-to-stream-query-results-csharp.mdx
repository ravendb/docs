import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

Query results can be streamed using the `Stream` method from the `Advanced` session operations. The query can be issued using either a static index, or it can be a dynamic one where it will be handled by an auto index.

Streaming query results does not support the [`include` feature](../../../../client-api/how-to/handle-document-relationships.mdx#includes). 
Instead, the query should rely on the [`load` clause](../../../../indexes/querying/what-is-rql.mdx#load). See 
[example IV](../../../../client-api/session/querying/how-to-stream-query-results.mdx#example-iv) below.  

<Admonition type="info" title="">
Entities loaded using `Stream` will be transient (not attached to session).
</Admonition>

## Syntax

<TabItem value="stream_1" label="stream_1">
<CodeBlock language="csharp">
{`// Define a query on a collection
IRavenQueryable<Employee> query = session
    .Query<Employee>()
    .Where(x => x.FirstName == "Robert");

// Call 'Stream' to execute the query
// Optionally, pass an 'out param' for getting the query stats
IEnumerator<StreamResult<Employee>> streamResults = 
    session.Advanced.Stream(query, out StreamQueryStatistics streamQueryStats);

// Read from the stream
while (streamResults.MoveNext())
\{
    // Process the received result
    StreamResult<Employee> currentResult = streamResults.Current;
    
    // Get the document from the result
    // This entity will Not be tracked by the session
    Employee employee = currentResult.Document;
    
    // The currentResult item also provides the following:
    var employeeId  = currentResult.Id;
    var documentMetadata = currentResult.Metadata;
    var documentChangeVector = currentResult.ChangeVector;

    // Can get info from the stats, i.e. get number of total results
    int totalResults = streamQueryStats.TotalResults;
    // Get the Auto-Index that was used/created with this dynamic query
    string indexUsed = streamQueryStats.IndexName;
\}
`}
</CodeBlock>
</TabItem>

| Parameters | | |
| ------------- | ------------- | ----- |
| **query** | [IQueryable](../../../../client-api/session/querying/how-to-query.mdx#sessionquery), [IDocumentQuery](../../../../client-api/session/querying/how-to-query.mdx#sessionadvanceddocumentquery) or [IRawDocumentQuery](../../../../client-api/session/querying/how-to-query.mdx#sessionadvancedrawquery) | Query to stream results for. |
| `out` **streamQueryStats** | [StreamQueryStatistics](../../../../glossary/stream-query-statistics.mdx) | Information about performed query. |

| Return Value | |
| ------------- | ----- |
| IEnumerator&lt;[StreamResult](../../../../glossary/stream-result.mdx)&gt; | Enumerator with entities. |

### Example I - Using Static Index

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IQueryable<Employee> query = session
    .Query<Employee, Employees_ByFirstName>()
    .Where(x => x.FirstName == "Robert");

IEnumerator<StreamResult<Employee>> results = session.Advanced.Stream(query);

while (results.MoveNext())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`IQueryable<Employee> query = asyncSession
    .Query<Employee, Employees_ByFirstName>()
    .Where(x => x.FirstName == "Robert");

Raven.Client.Util.IAsyncEnumerator<StreamResult<Employee>> results = await asyncSession.Advanced.StreamAsync(query);

while (await results.MoveNextAsync())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example II - Dynamic Document Query

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IDocumentQuery<Employee> query = session
    .Advanced
    .DocumentQuery<Employee>()
    .WhereEquals(x => x.FirstName, "Robert");

StreamQueryStatistics streamQueryStats;
IEnumerator<StreamResult<Employee>> results = session.Advanced.Stream(query, out streamQueryStats);

while (results.MoveNext())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`IAsyncDocumentQuery<Employee> query = asyncSession
    .Advanced
    .AsyncDocumentQuery<Employee>()
    .WhereEquals(x => x.FirstName, "Robert");

Raven.Client.Util.IAsyncEnumerator<StreamResult<Employee>> results = await asyncSession.Advanced.StreamAsync(query);

while (await results.MoveNextAsync())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Example III - Dynamic Raw Query

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IRawDocumentQuery<Employee> query = session
    .Advanced
    .RawQuery<Employee>("from Employees where FirstName = 'Robert'");

IEnumerator<StreamResult<Employee>> results = session.Advanced.Stream(query);

while (results.MoveNext())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`IAsyncRawDocumentQuery<Employee> query = asyncSession
    .Advanced
    .AsyncRawQuery<Employee>("from Employees where FirstName = 'Robert'");

Raven.Client.Util.IAsyncEnumerator<StreamResult<Employee>> results = await asyncSession.Advanced.StreamAsync(query);

while (await results.MoveNextAsync())
{
    StreamResult<Employee> employee = results.Current;
}
`}
</CodeBlock>
</TabItem>
</Tabs>

## Alternative to Using Includes

Streaming does not support the [`include` feature](../../../../client-api/how-to/handle-document-relationships.mdx#includes). 
An `include` clause in a query loads additional documents related to the primary target of the query. 
These are stored in the session on the client side so that they can be accessed without an additional 
query.  

In a normal non-streamed query, included documents are sent at the end of results, after the 
main targets and documents added with `load`. This does not mesh well with streaming, which is 
designed to allow transferring massive amounts of data, possibly over a significant amount of time. 
Instead of getting related documents at the end of the stream, it is better to get them interspersed 
with the other results.  

### Example IV

To include related documents in your query, add them using `load`, then use `select` to 
retrieve the documents.  

Because we used `select`, the query results are now a [projection](../../../../indexes/querying/projections.mdx) containing more than 
one entity. So on the client side, you need a projection class that matches the query result.  

In this example, we query the `Orders` collection and also load related `Company` and 
`Employee` documents. With the select clause, we return all three objects. We have a class 
called `MyProjection` that has the three entity types as properties. We use this class to 
store the results.  

<Tabs groupId='languageSyntax'>
<TabItem value="Sync" label="Sync">
<CodeBlock language="csharp">
{`IRawDocumentQuery<MyProjection> query = session
    .Advanced
    .RawQuery<MyProjection>(@"from Orders as o 
                            where o.ShipTo.City = 'London'
                            load o.Company as c, o.Employee as e
                            select {
                                order: o,
                                company: c,
                                employee: e
                            }");


IEnumerator<StreamResult<MyProjection>> results = session.Advanced.Stream(query);

while (results.MoveNext())
{
    StreamResult<MyProjection> projection = results.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Async" label="Async">
<CodeBlock language="csharp">
{`IAsyncRawDocumentQuery<MyProjection> query = asyncSession
    .Advanced
    .AsyncRawQuery<MyProjection>(@"from Orders as o 
                                   where o.ShipTo.City = 'London'
                                   load o.Company as c, o.Employee as e
                                   select {
                                       order: o,
                                       company: c,
                                       employee: e
                                   }");


Raven.Client.Util.IAsyncEnumerator<StreamResult<MyProjection>> results = await asyncSession.Advanced.StreamAsync(query);

while (await results.MoveNextAsync())
{
    StreamResult<MyProjection> projection = results.Current;
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Class" label="Class">
<CodeBlock language="csharp">
{`public class MyProjection
{
    public Order order { get; set; }
    public Employee employee { get; set; }
    public Company company { get; set; }
}
`}
</CodeBlock>
</TabItem>

</Tabs>


