import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import ContentFrame from '@site/src/components/ContentFrame';
import Panel from '@site/src/components/Panel';

<Admonition type="note" title="">

* Queries in RavenDB can be written with:
    * The session's `query` method - rich API is provided
    * The session's `rawQuery` method - using RQL
    * The [Query view](../studio/database/queries/query-view.mdx) in Studio - using RQL

* Queries defined with the `query` method are translated by the RavenDB client to [RQL](../client-api/session/querying/what-is-rql.mdx)  
  when sent to the server.
    
* All queries in RavenDB use an **index** to provide results, even when you don't specify one.  
  Learn more [below](../client-api/session/querying/how-to-query.mdx#queries-always-provide-results-using-an-index).

* Queries that do Not specify which index to use are called **Dynamic Queries**.  
  This article displays examples of dynamic queries only.  
  For examples showing how to query an index see [querying an index](../indexes/querying/query-index.mdx).
    
* The entities returned by the query are 'loaded' and **tracked** by the [Session](../client-api/session/what-is-a-session-and-how-does-it-work.mdx).  
  Entities will Not be tracked when:  
    * Query returns a [projection](../client-api/session/querying/how-to-project-query-results.mdx)  
    * Tracking is [disabled](../client-api/session/configuration/how-to-disable-tracking.mdx#disable-tracking-query-results)  

* Query results are **cached** by default. To disable query caching see [noCaching](../client-api/session/querying/how-to-customize-query.mdx#nocaching).  

* Queries are timed out after a configurable time period.  See [query timeout](../server/configuration/database-configuration.mdx#databasesquerytimeoutinsec).
    
* In this article:
  * [Queries always provide results using an index](../client-api/session/querying/how-to-query.mdx#queries-always-provide-results-using-an-index)  
  * [session.query](../client-api/session/querying/how-to-query.mdx#session-query)  
  * [session.advanced.rawQuery](../client-api/session/querying/how-to-query.mdx#session-advanced-rawquery)
  * [query API](../client-api/session/querying/how-to-query.mdx#query-api)  
  * [Syntax](../client-api/session/querying/how-to-query.mdx#syntax)

</Admonition>

<Panel heading="Queries always provide results using an index">

* Queries always use an index to provide fast results regardless of the size of your data.

* When a query reaches a RavenDB instance, the instance calls its query optimizer to analyze the query  
  and determine which index should be used to retrieve the requested data.

* Indexes allow to provide query results without scanning the entire dataset each and every time.
    * Learn more about indexes, their general concept, and the different **index types** in this [indexes overview](../studio/database/indexes/indexes-overview.mdx) article.
    * You can choose the underlying **search engine** that will be used by the RavenDB indexes.  
      Learn more in [selecting the search engine](../indexes/search-engine/corax.mdx#selecting-the-search-engine).

<Admonition type="info" title="">

We differentiate between the following **3 query scenarios**:

1. [Index query](../client-api/session/querying/how-to-query.mdx#indexquery)
2. [Dynamic query](../client-api/session/querying/how-to-query.mdx#dynamicquery)
3. [Full collection query](../client-api/session/querying/how-to-query.mdx#collectionquery)

For each scenario, a different index type is used, as described below.

</Admonition>
    
<Admonition type="note" title="">

<a id="indexQuery"/> 
**1. Query an existing index**:

*  **Query type**: Index query  
   **Index used**: Static-index

* You can specify which **STATIC-static index** the query will use.

* Static indexes are defined by the user, as opposed to auto-indexes that are created by the server  
  when querying a collection with some filtering applied. See [Static-index vs Auto-index](../studio/database/indexes/indexes-overview.mdx#auto-indexes--vs--static-indexes).

* Example RQL: &nbsp; `from index "Employees/ByFirstName" where FirstName == "Laura"`  
  See more examples in [querying an index](../indexes/querying/query-index.mdx).

</Admonition>
    
<Admonition type="note" title="">

<a id="dynamicQuery"/> 
**2. Query a collection - with filtering (Dynamic Query)**:

*  **Query type**: Dynamic Query  
   **Index used**: Auto-index

* When querying a collection without specifying an index and with some filtering condition  
  (other than just the document ID) the query-optimizer will analyze the query to see if an **AUTO-index**  
  that can answer the query already exists, i.e. an auto-index on the collection queried with index-fields that match those queried.

* If such auto-index (Not a static one...) is found, it will be used to fetch the results.

* Else, if no relevant auto-index is found,  
  the query-optimizer will create a new auto-index with fields that match the query criteria.  
  At this time, and only at this time, the query will wait for the auto-indexing process to complete.  
  Subsequent queries that target this auto-index will be served immediately.

* Note: if there exists an auto-index that is defined on the collection queried  
  but is indexing a different field than the one queried on,  
  then the query-optimizer will create a new auto-index that merges both the  
  fields from the existing auto-index and the new fields queried.

* Once the newly created auto-index is done indexing the data,  
  the old auto-index is removed in favor of the new one.

* Over time, an optimal set of indexes is generated by the query optimizer to answer your queries.

* Example RQL: &nbsp; `from Employees where FirstName == "Laura"`  
  See more examples [below](../client-api/session/querying/how-to-query.mdx#sessionquery).
* Note: Counters and Time series are an exception to this flow.  
  Dynamic queries on counters and time series values don't create auto-indexes.  
  However, a static-index can be defined on [Time series](../document-extensions/timeseries/indexing.mdx) and [Counters](../document-extensions/counters/indexing.mdx).

</Admonition>
    
<Admonition type="note" title="">

<a id="collectionQuery"/> 
**3. Query a collection - no filtering**:

* **Query type**: Full collection Query  
  **Index used**: The raw collection (internal storage indexes)

* Full collection query:

  * When querying a collection without specifying an index and with no filtering condition,  
    then all documents from the specified collection are returned.

  * RavenDB uses the raw collection documents in its **internal storage indexes** as the source for this query.  
    No auto-index is created.

  * Example RQL: &nbsp; `from Employees`

* Query by document ID:
 
  * When querying a collection only by document ID or IDs,  
    then similar to the full collection query, no auto-index is created.  
  
  * RavenDB uses the raw collection documents as the source for this query.
  
  * Example RQL: &nbsp; `from Employees where id() == "employees/1-A"`  
    See more examples [below](../client-api/session/querying/how-to-query.mdx#sessionquery).

</Admonition>

</Panel>

<Panel heading="session.query">

* The simplest way to issue a query is by using the session's `query` method.    
  Customize your query with these [API methods](../client-api/session/querying/how-to-query.mdx#query-api).

* The following examples show **dynamic queries** that do not specify which index to use.  
  Please refer to [querying an index](../indexes/querying/query-index.mdx) for other examples.

<ContentFrame>

**Query collection - no filtering** 

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
// This is a Full Collection Query
// No auto-index is created since no filtering is applied

// Query for all documents from 'employees' collection
const employees = await session.query({ collection: "employees" })
    // Execute the query
    .all();

// All 'employee' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="Query_overload" label="Query_overload">
```js
// This is a Full Collection Query
// No auto-index is created since no filtering is applied

// Query for all documents from 'employees' collection
const employees = await session.query(Employee)
    // Execute the query
    .all();

// All 'employee' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
// This RQL is a Full Collection Query
// No auto-index is created since no filtering is applied

from "employees"
```
</TabItem>
</Tabs>

</ContentFrame>

<ContentFrame>

**Query collection - by ID**

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
// Query collection by document ID
// No auto-index is created when querying only by ID

const employee = await session.query({ collection: "employees" })
    .whereEquals("id()", "employees/1-A") // Query for specific document from 'employees' collection 
    .first();                             // Execute the query

// The resulting 'employee' entity is loaded and will be tracked by the session
```
</TabItem>
<TabItem value="Query_overload" label="Query_overload">
```js
// Query collection by document ID
// No auto-index is created when querying only by ID

const employee = await session.query(Employee)
    .whereEquals("id()", "employees/1-A") // Query for specific document from 'employees' collection 
    .first();                             // Execute the query

// The resulting 'employee' entity is loaded and will be tracked by the session
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
// This RQL queries the 'Employees' collection by ID
// No auto-index is created when querying only by ID

from "employees" where id() == "employees/1-A"
```
</TabItem>
</Tabs>

</ContentFrame>

<ContentFrame>

**Query collection - with filtering** 

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
// Query collection - filter by document field

// An auto-index will be created if there isn't already an existing auto-index
// that indexes this document field

const employees = await session.query({ collection: "employees" })
    .whereEquals("firstName", "Robert") // Query for all 'employee' documents that match this predicate 
    .all();                             // Execute the query

// The resulting 'employee' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="Query_overload" label="Query_overload">
```js
// Query collection - filter by document field

// An auto-index will be created if there isn't already an existing auto-index
// that indexes this document field

const employees = await session.query(Employee)
    .whereEquals("firstName", "Robert") // Query for all 'employee' documents that match this predicate 
    .all();                             // Execute the query

// The resulting 'employee' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
// Query collection - filter by document field

// An auto-index will be created if there isn't already an existing auto-index
// that indexes the requested field

from "employees" where firstName == "Robert"
```
</TabItem>
</Tabs>

</ContentFrame>

<ContentFrame>

**Query collection - with paging** 

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
// Query collection - page results
// No auto-index is created since no filtering is applied

const products = await session.query({ collection: "products" })
    .skip(5)  // Skip first 5 results
    .take(10) // Load up to 10 entities from 'products' collection
    .all();   // Execute the query

// The resulting 'product' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="Query_overload" label="Query_overload">
```js
// Query collection - page results
// No auto-index is created since no filtering is applied

const products = await session.query(Employee)
    .skip(5)  // Skip first 5 results
    .take(10) // Load up to 10 entities from 'products' collection
    .all();   // Execute the query

// The resulting 'product' entities are loaded and will be tracked by the session
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
// Query collection - page results
// No auto-index is created since no filtering is applied

from "products" limit 5, 10 // skip 5, take 10
```
</TabItem>
</Tabs>

* By default, if the page size is not specified, all matching records will be retrieved from the database.

</ContentFrame>

</Panel>

<Panel heading="session.advanced.rawQuery">

* Queries defined with [query](../client-api/session/querying/how-to-query.mdx#sessionquery) are translated by the RavenDB client to [RQL](../client-api/session/querying/what-is-rql.mdx) when sent to the server.  

* The session also gives you a way to express the query directly in RQL using the `rawQuery` method.

**Example**:

<TabItem>
```js
// Query with rawQuery - filter by document field

// An auto-index will be created if there isn't already an existing auto-index
// that indexes this document field

const employees = await session.advanced
     // Provide RQL to rawQuery
    .rawQuery("from employees where firstName = 'Robert'")
     // Execute the query
    .all();

// The resulting 'employee' entities are loaded and will be tracked by the session 
```
</TabItem>

</Panel>

<Panel heading="query API">

Available methods for the session's [query](../client-api/session/querying/how-to-query.mdx#sessionquery) method:

- addOrder
- addParameter
- aggregateBy
- aggregateUsing
- andAlso
- any
- [boost](../client-api/session/querying/text-search/boost-search-results.mdx)
- closeSubclause
- containsAll
- containsAny
- [count](../client-api/session/querying/how-to-count-query-results.mdx)
- [countLazily](../client-api/session/querying/how-to-perform-queries-lazily.mdx#lazy-count-query)
- distinct
- first
- firstOrNull
- fuzzy
- getIndexQuery
- getQueryResult
- [groupBy](../client-api/session/querying/how-to-perform-group-by-query.mdx)
- [highlight](../client-api/session/querying/text-search/highlight-query-results.mdx)
- include
- [includeExplanations](../client-api/session/querying/debugging/include-explanations.mdx)
- [intersect](../client-api/session/querying/how-to-use-intersect.mdx)
- lazily
- [longCount](../client-api/session/querying/how-to-count-query-results.mdx)
- [moreLikeThis](../client-api/session/querying/how-to-use-morelikethis.mdx)
- negateNext
- [noCaching](../client-api/session/querying/how-to-customize-query.mdx#nocaching)
- [noTracking](../client-api/session/querying/how-to-customize-query.mdx#notracking)
- not
- [ofType](../client-api/session/querying/how-to-project-query-results.mdx#oftype)
- [on("afterQueryExecuted")](../client-api/session/querying/how-to-customize-query.mdx#on-("afterqueryexecuted"))
- [on("beforeQueryExecuted")](../client-api/session/querying/how-to-customize-query.mdx#on-("beforequeryexecuted"))
- openSubclause
- [orderBy](../client-api/session/querying/sort-query-results.mdx)
- [orderByDescending](../client-api/session/querying/sort-query-results.mdx)
- [orderByDistance](../client-api/session/querying/how-to-make-a-spatial-query.mdx#orderbydistance)
- [orderByDistanceDescending](../client-api/session/querying/how-to-make-a-spatial-query.mdx#orderbydistancedesc)
- [orderByScore](../client-api/session/querying/sort-query-results.mdx#order-by-score)
- [orderByScoreDescending](../client-api/session/querying/sort-query-results.mdx#order-by-score)
- orElse
- proximity
- [randomOrdering](../client-api/session/querying/how-to-customize-query.mdx#randomordering)
- relatesToShape
- search
- [selectFields](../indexes/querying/projections.mdx#selectfields)
- selectTimeSeries
- single
- singleOrNull
- skip
- spatial
- [statistics](../client-api/session/querying/how-to-get-query-statistics.mdx)
- [suggestUsing](../client-api/session/querying/how-to-work-with-suggestions.mdx)
- take
- timings
- usingDefaultOperator
- [waitForNonStaleResults](../client-api/session/querying/how-to-customize-query.mdx#waitfornonstaleresults)
- whereBetween
- [whereEndsWith](../client-api/session/querying/text-search/ends-with-query.mdx)
- whereEquals
- [whereExists](../client-api/session/querying/how-to-filter-by-field.mdx)
- whereGreaterThan
- whereGreaterThanOrEqual
- whereIn
- whereLessThan
- whereLessThanOrEqual
- [whereLucene](../client-api/session/querying/document-query/how-to-use-lucene.mdx)
- whereNotEquals
- [whereRegex](../client-api/session/querying/text-search/using-regex.mdx)
- [whereStartsWith](../client-api/session/querying/text-search/starts-with-query.mdx)
- withinRadiusOf

</Panel>

<Panel heading="Syntax">

<TabItem>
```js
// Overload for querying a collection:
session.query(documentType);

// Overload for querying an index:
session.query(documentType, index);

// Overload for querying a collection OR an index:
session.query(opts);

// rawQuery:
session.rawQuery(query);
```
</TabItem>

| Parameter        | Type                          | Description                  |
|------------------|-------------------------------|------------------------------|
| **documentType** | object                        | The type of entities queried |
| **index**        | object                        | The index class              |
| **opts**         | `DocumentQueryOptions` object | Query options                |
| **query**        | string                        | The RQL query string         |

| `DocumentQueryOptions` | | |
| - | - | - |
|  **collection** | string | &lt;ul&gt;&lt;li&gt;Collection name queried&lt;/li&gt;&lt;/ul&gt; |
|  **indexName** | string | &lt;ul&gt;&lt;li&gt;Index name queried&lt;/li&gt;&lt;/ul&gt; |
|  **index** | object | &lt;ul&gt;&lt;li&gt;Index object queried&lt;/li&gt;&lt;li&gt;Note:<br/>`indexName` & `index` are mutually exclusive with `collection`.<br/>See examples in [querying an index](../indexes/querying/query-index.mdx).&lt;/li&gt;&lt;/ul&gt; |

| Return Value | |
| - | - |
| `object` | Instance implementing `IDocumentQuery` exposing the additional [query methods](../client-api/session/querying/how-to-query.mdx#query-api). |

* Note:  
  Use `await` when executing the query, e.g. when calling `.all`, `.single`, `.first`, `.count`, etc.  

</Panel>