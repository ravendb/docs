# Indexes Overview
---

{NOTE: }

* RavenDB uses **Indexes** in order to be able to answer queries about your documents.  

* Indexes allow for fast query results as the entire dataset is not re-scanned each and every time.  

* Indexes can created:
  * From Studio  
  * From code - see [Creating Indexes and Deploying Indexes](../../../indexes/creating-and-deploying)  
  * Auto indexes are generated by the server - see [Auto-Map Index Generation](../../../indexes/creating-and-deploying#auto-indexes)  

* In this page:  

  * [Indexes - The General Concept](../../../studio/database/indexes/indexes-overview#indexes---the-general-concept)  
  * [Indexes - The Moving Parts](../../../studio/database/indexes/indexes-overview#indexes---the-moving-parts) : 
    [Index Definition](../../../studio/database/indexes/indexes-overview#index-definition), 
    [Indexing Process](../../../studio/database/indexes/indexes-overview#indexing-process), 
    [Indexed Data](../../../studio/database/indexes/indexes-overview#indexed-data)  
  * [Indexes Types](../../../studio/database/indexes/indexes-overview#indexes-types)  
  * [Fields Configuration Options](../../../studio/database/indexes/indexes-overview#fields-configuration-options)
  * [Modifying Index Definition](../../../studio/database/indexes/indexes-overview#modifying-index-definition)
  * [Indexes in the Cluster](../../../studio/database/indexes/indexes-overview#indexes-in-the-cluster)
  * [Indexing Errors](../../../studio/database/indexes/indexes-overview#indexing-errors)
{NOTE/}

---

{PANEL: Indexes - The General Concept}

* In order to be able to return query results about your documents _without_ scanning the entire dataset each and every time,  
  RavenDB uses **Indexes**.  

* Once defined, the index iterates over the documents, and for every field (document property) that is requested to be indexed,  
  a **map** is built between the terms derived from these fields and the actual documents that contain them.  

* A **query** operating on these fields ends up with a simple search from the queried terms to the list of documents that contain them.  

* After the first **indexing** run, the index will keep that map current _without_ re-processing the entire index data -  
  only update the relevant details when a document update happens in the database.  

* Indexes are not stored in the 'document store' but have their own separate storage.  

* Indexes in RavenDB are split across multiple axes (see more [below](../../../studio/database/indexes/indexes-overview#indexes-types))

  * Auto Indexes -vs- Static Indexes  
  * Map Indexes -vs- Map-Reduce Indexes  
  * Single-Collection Indexes -vs- Multi-Collection Indexes  
{PANEL/}

{PANEL: Indexes - The Moving Parts}

{NOTE: }

#### 1. Index Definition

* **The index definition** tells RavenDB how to index the data.  

* It specifies the fields to be indexed and how those fields should be indexed (i.e. allowing a full-text-search option).  
  These fields can be specified explicitly or defined dynamically supporting any document structure.  

* The index definition is created by the client (**Static-Index**), or by the server Query Optimizer(**Auto-Index**).  

* Note: Data from related documents can also be indexed using 'LoadDocument'. Learn more in [Indexing Related Documents](../../../indexes/indexing-related-documents).  
{NOTE/}

{NOTE: }

#### 2. Indexing Process

* **Indexing** is the process of indexing the data, iterating over the documents and creating a map  
  between the terms indexed and the actual documents that contain them.  

* Indexing is a background operation, it is scheduled to occur in an async manner for any document change.  
  e.g. A document write operation doesn't wait for the index to complete processing -  
  The write operation is completed as soon as the transaction is written to disk.  

* An index is considered [Stale](../../../indexes/stale-indexes) if it had not yet processed all of the data.  

* A query can request that results are returned only when the index is up-to-date.  
  A write operation can wait for the indexing process to complete before acknowledging the write  
  See: [Understanding Eventual Consistency](../../../users-issues/understanding-eventual-consistency)

* The async indexing process works with hard resets, shutdowns and the like.  
  If the database was restarted _after_ a document was modified but _before_ it was indexed,  
  the indexing process will just pick up from where it left off and complete the work.  

* Each index is assigned a dedicated thread, thus no indexing process can interfere with any other.  
  By default, indexing-threads start with a lower priority than request-processing threads.  
  The indexing-thread priority can be set higher and RavenDB will update this at the operating system level.
{NOTE/}

{NOTE: }

#### 3. Indexed Data

* The resulting output of 'step 2' (the indexing process) is also referred to as an Index.  
  It is the **indexed data** on which queries can operate on to get documents result.  

* Note: The full document is _not_ stored in the index - only the document ID.  
  Upon a query match, we load the document itself from the document storage.  

* **Index Entry**  
  _Index-Entries_ are all of the document fields that are requested to be indexed, as defined in the index-definition.  

* **Term**  
  The index-entries values are broken into _Terms_ according to the specified analyzer used in the index-definition.  
  _Term_ is the actual indexed value that is stored in the index.  

* **Stored Data**  
  In addition to the _Terms_, some document fields can be stored directly in the index data.  
  This allows for query results to be fetched from the index itself instead of loading the original document.  
{NOTE/}
{PANEL/}

{PANEL: Index Types}

Indexes in RavenDB are split across the following multiple axes:

{NOTE: Auto Indexes -vs- Static Indexes}

* **Auto Indexes**:  
  When a Query doesn't specify a specific index to be used, the server [Query Optimizer](../../../indexes/querying/what-is-rql#query-optimizer) will first analyze the query 
  and search for an already existing Auto-Index that can answer the query.
  If there is no such index, the Query Optimizer creates on the fly an Auto-Index that can answer this query and all previous queries on that collection.  
  When the new Auto-Index has caught up, RavenDB cleans up all the old Auto-Indexes that are now superseded by the new one.  

* **Static Indexes**:  
  Created by the user (database administrator only) from the Studio or from the Client API.  
  The index-shape (as defined in the index-definition) and the shape of the source document don't have to be the same,  
  as the indexed-data can be a computed value. These computations are run during the indexing-process and not at query time.  
{NOTE/}

{NOTE: Map Indexes -vs- Map-Reduce Indexes}

* **Map Indexes**:  
  [Map indexes](../../../studio/database/indexes/create-map-index) are simple indexes.  
  Contain one or more LINQ-based mapping functions indicating what should be indexed from the document,  
  and how it should be indexed, as these functions allow you to compute the indexed value.  

* **Map-Reduce Indexes**:  
  [Map-Reduce indexes](../../../studio/database/indexes/create-map-reduce-index) allow performing complex **aggregations** of data.  
  The _Map_ stage is similar to a regular Map-Index, defining what data should be indexed.  
  The _Reduce_ stage operates on the Map results, specifying how the data should be grouped and aggregated.  
{NOTE/}

{NOTE: Single-Collection Indexes -vs- Multi-Collection Indexes}

* **Single-Collection Indexes**:  
  Index definition contains only one Map function defined on a specific collection.  

* **Multi-Collection Indexes**:  
  Data from several collections can be indexed (each in a different Map) and the results are united in a single index.  
  The only requirement is that all the Map definitions have the same output shape.  
{NOTE/}
{PANEL/}

{PANEL: Field Configuration Options}

Additional settings can be specified per field in the index-entry definition, configuring how the terms are indexed inside RavenDB. 
See [here](../../../studio/database/indexes/create-map-index) to learn how to set thes options in the Studio.  

* **Full Text Search**  
  The original field data is split and tokenized according to the selected analyzer. Learn more about analyzers [here](../../../indexes/using-analyzers#full-text-search).  

  * Suggestions - Allow finding similar results to the string in your query. i.e. Martin -> Martine.  
  * Term Vector - Allow finding similar documents based on shared indexed terms.  

* **Spatial**  
  Allow geographical querying on longitude and latitude values or WKT values provided from the document.  
  Customize the spatial indexing strategy.  
  Learn more in: [Indexing Spatial Data](../../../indexes/indexing-spatial-data)

* **Store Field**  
  Field can be stored within the indexed-data.  
  This allows retrieving the value from the indexed-data at query time, instead of loading the original document.  
  Learn more in: [Storing Data in Index](../../../indexes/storing-data-in-index)
{PANEL/}

{PANEL: Modifying Index Definition}

* Only an index that is not set as 'Locked' can actually be modified.  

* When the index-definition has changed in a way that invalidates the previous indexing results,  
  the modification is handled in a **side-by-side** manner.  
  e.g. A mapping function change will invalidate previous results, while a change in priority will not.  

* The original index is retained and is fully operable while the new index (with the new definition) is being built.  
  Once the new index is up-to-date the original index is removed in favor of the new one.  

* See example in [Indexes List View - Side by Side](../../../studio/database/indexes/indexes-list-view#indexes-list-view---side-by-side-indexing).  

* RavenDB keeps a [history of index revisions](../../../studio/database/indexes/index-history), 
  allowing you to revert an index to any of its past revisions.  
  The number of index revisions kept can be configured in the 
  [Server Configuration Options](../../../server/configuration/configuration-options), 
  or using the [Database Settings view](../../../studio/database/indexes/index-history#view-and-update-number-of-index-revisions) 
  in the Studio.
{PANEL/}

{PANEL: Indexes in the Cluster}

* Index & Auto-Index creation is a cluster operation. It goes through the [Raft protocol](../../../server/clustering/rachis/what-is-rachis#rachis---ravendbs-raft-implementation).  
  Index creation will fail if the majority of the nodes in the cluster is not reachable.  

* Once an index is created against any node in the [Database Group](../../../studio/database/settings/manage-database-group), 
  RavenDB will make sure that its definition is replicated to all the database's nodes. 
  The indexing-process will occur separately on each node.  

* Note: The [External Replication](../../../studio/database/tasks/ongoing-tasks/external-replication-task) ongoing-task does NOT replicate indexes.  
{PANEL/}

{PANEL: Indexing Errors}

* An error in indexing a document means that this particular document is not indexed and you will not see it in the query result.  

* An index is only allowed a certain failure rate, above which it is marked in an error state.  
  An index in an error state cannot be queried and will return an immediate error.  

* See more in [Indexes List View - Errors](../../../studio/database/indexes/indexes-list-view#indexes-list-view---errors).  
{PANEL/}

## Related Articles

### Indexes
- [What are Indexes](../../../indexes/what-are-indexes)
- [Creating & Deploying Indexes](../../../indexes/creating-and-deploying)
- [Indexing Basics](../../../indexes/indexing-basics)

### Studio
- [Studio Indexes List View](../../../studio/database/indexes/indexes-list-view)  
- [Index History](../../../studio/database/indexes/index-history)
