import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Prior to reading this article, please refer to [full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) 
  to learn about the `search` method.  

* **All capabilities** provided by `search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this article:
  * [Indexing single field for FTS](../../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../../indexes/querying/searching.mdx#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../../indexes/querying/searching.mdx#boosting-search-results)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="python">
{`class Employees_ByNotes(AbstractIndexCreationTask):
    # The IndexEntry class defines the index-fields
    class IndexEntry:
        def __init__(self, employee_notes: str = None):
            self.employee_notes = employee_notes

    def __init__(self):
        super().__init__()
        # The 'Map' function defines the content of the index-fields
        self.map = "from employee in docs.Employees " "select new " "\{ " " employee_notes = employee.Notes[0]" "\}"

        # Configure the index-field for FTS:
        # Set 'FieldIndexing.Search' on index-field 'employee_notes'
        self._index("employee_notes", FieldIndexing.SEARCH)

        # Optionally: Set your choice of analyzer for the index-field:
        # Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        self._analyze("employee_notes", "WhitespaceAnalyzer")

        # Note:
        # If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the index
    .query_index_type(Employees_ByNotes, Employees_ByNotes.IndexEntry)
    # Call 'search':
    # pass the index field that was configured for FTS and the term to search for.
    .search("employee_notes", "French").of_type(Employee)
)
# * Results will contain all Employee documents that have 'French' in their 'Notes' field.

# * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
#   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="python">
{`class Employees_ByEmployeeData(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, employee_data: List = None):
            self.employee_data = employee_data

    def __init__(self):
        super().__init__()
        self.map = (
            "from employee in docs.Employees "
            "select new \{"
            "  employee_data = "
            "  \{"
            # Multiple document-fields can be indexed
            # into the single index-field 'employee_data'
            "    employee.FirstName,"
            "    employee.LastName,"
            "    employee.Title,"
            "    employee.Notes"
            "  \}"
            "\}"
        )
        # Configure the index-field for FTS:
        # Set 'FieldIndexing.SEARCH' on index-field 'employee_data'
        self._index("employee_data", FieldIndexing.SEARCH)

        # Note:
        # Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`employees = list(
    session
    # Query the static-index
    .query_index_type(Employees_ByEmployeeData, Employees_ByEmployeeData.IndexEntry)
    .open_subclause()
    # A logical OR is applied between the following two search calls
    .search("employee_data", "Manager")
    # A logical AND is applied between the following two terms
    .search("employee_data", "French Spanish", operator=SearchOperator.AND)
    .close_subclause()
    .of_type(Employee)
)

# * Results will contain all Employee documents that have:
#   ('Manager' in any of the 4 document-fields that were indexed)
#   OR
#   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)

# * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly, use the `AsJson` method,
  which is available in the **C# LINQ string** that is assigned to the `map` property in the Python index class,
  as shown in the example below.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`,
  the index automatically includes values from ALL existing and newly added properties
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="index_3" label="index_3">
<CodeBlock language="python">
{`class Products_ByAllValues(AbstractIndexCreationTask):
    class IndexEntry:
        def __init__(self, all_values: str = None):
            self.all_values = all_values

    def __init__(self):
        super().__init__()
        self.map = (
            "docs.Products.Select(product => new \{ "
            # Use the 'AsJson' method to convert the document into a JSON-like structure
            # and call 'Select' to extract only the values of each property
            "    all_values = this.AsJson(product).Select(x => x.Value) "
            "\})"
        )
        
        # Configure the index-field for FTS:
        # Set 'FieldIndexing.SEARCH' on index-field 'all_values'
        self._index("all_values", FieldIndexing.SEARCH)
        
        # Note:
        # Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
        
        # Set the search engine type to Lucene:
        self.search_engine_type = SearchEngineType.LUCENE
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="python">
{`products = list(
    session.query_index_type(Products_ByAllValues, Products_ByAllValues.IndexEntry)
    .search("all_values", "tofu")
    .of_type(Product)
)

# * Results will contain all Product documents that have 'tofu'
#   in ANY of their fields.
#
# * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(all_values, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to the indexes [Boosting](../../../indexes/boosting.mdx) article.  

  * Add a boost value to the queried terms **at query time**.  
    Refer to the [Boost search results](../../../client-api/session/querying/text-search/boost-search-results.mdx) article.  




