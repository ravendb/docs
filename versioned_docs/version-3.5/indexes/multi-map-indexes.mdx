---
title: "Multi-Map indexes"
sidebar_label: Multi-Map Indexes
sidebar_position: 6
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Multi-Map indexes

Multi-Map indexes allow you to index data from multiple collections e.g. polymorphic data (check the [example](../indexes/indexing-polymorphic-data.mdx)) or any common data between types.

## AddMap & AddMapForAll

`AddMap` method is used to map fields from a single collection e.g. `Dogs`. On the other hand, `AddMapForAll` gives you the ability to specify what fields will be indexed from base class. 

Let's assume that we have a `Dog` and a `Cat` classes, and both of them inherit from the `Animal`:

<Tabs groupId='languageSyntax'>
<TabItem value="Dog" label="Dog">
<CodeBlock language="csharp">
{`public class Dog : Animal
{

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Cat" label="Cat">
<CodeBlock language="csharp">
{`public class Cat : Animal
{

}
`}
</CodeBlock>
</TabItem>
<TabItem value="Animal" label="Animal">
<CodeBlock language="csharp">
{`public abstract class Animal : IAnimal
{
	public string Name { get; set; }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="IAnimal" label="IAnimal">
<CodeBlock language="csharp">
{`public interface IAnimal
{
	string Name { get; set; }
}
`}
</CodeBlock>
</TabItem>
</Tabs>

Now we can define our index using `AddMap` or `AddMapForAll` in the following way:

<Tabs groupId='languageSyntax'>
<TabItem value="AddMap" label="AddMap">
<CodeBlock language="csharp">
{`public class Animals_ByName : AbstractMultiMapIndexCreationTask
{
	public Animals_ByName()
	{
		AddMap<Cat>(cats => from c in cats select new { c.Name });

		AddMap<Dog>(dogs => from d in dogs select new { d.Name });
	}
}
`}
</CodeBlock>
</TabItem>
<TabItem value="AddMapForAll" label="AddMapForAll">
<CodeBlock language="csharp">
{`public class Animals_ByName_ForAll : AbstractMultiMapIndexCreationTask
{
	public Animals_ByName_ForAll()
	{
		AddMapForAll<Animal>(parents => from p in parents select new { p.Name });
	}
}
`}
</CodeBlock>
</TabItem>
</Tabs>

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`IList<IAnimal> results = session
	.Query<IAnimal, Animals_ByName>()
	.Where(x => x.Name == "Mitzy")
	.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`IList<IAnimal> results = session
	.Advanced
	.DocumentQuery<IAnimal, Animals_ByName>()
	.WhereEquals(x => x.Name, "Mitzy")
	.ToList();
`}
</CodeBlock>
</TabItem>
<TabItem value="Commands" label="Commands">
<CodeBlock language="csharp">
{`QueryResult result = store
	.DatabaseCommands
	.Query(
		"Animals/ByName",
		new IndexQuery
		{
			Query = "Name:Mitzy"
		});
`}
</CodeBlock>
</TabItem>
</Tabs>

## Indexing polymorphic data

Please read more in our dedicated article on indexing polymorphic data. This article can be found [here](../indexes/indexing-polymorphic-data.mdx).

## Searching across multiple collections

Another great application of Multi-Map indexes is smart-search. Imagine that you want to search for products, companies, or employees by their name. In order to do it, you need to define  the following index:

<TabItem value="multi_map_1_0" label="multi_map_1_0">
<CodeBlock language="csharp">
{`public class Smart_Search : AbstractMultiMapIndexCreationTask<Smart_Search.Result>
\{
    public class Result
    \{
        public string Id \{ get; set; \}

        public string DisplayName \{ get; set; \}

        public object Collection \{ get; set; \}

        public string[] Content \{ get; set; \}
    \}

    public class Projection
    \{
        public string Id \{ get; set; \}

        public string DisplayName \{ get; set; \}

        public string Collection \{ get; set; \}
    \}

    public Smart_Search()
    \{
        AddMap<Company>(companies => from c in companies
            select new Result
            \{
                Id = c.Id,
                Content = new[]
                \{
                    c.Name
                \},
                DisplayName = c.Name,
                Collection = MetadataFor(c)["@collection"]
            \});

        AddMap<Product>(products => from p in products
            select new Result
            \{
                Id = p.Id,
                Content = new[]
                \{
                    p.Name
                \},
                DisplayName = p.Name,
                Collection = MetadataFor(p)["@collection"]
            \});

        AddMap<Employee>(employees => from e in employees
            select new Result
            \{
                Id = e.Id,
                Content = new[]
                \{
                    e.FirstName,
                    e.LastName
                \},
                DisplayName = e.FirstName + " " + e.LastName,
                Collection = MetadataFor(e)["@collection"]
            \});

        // mark 'Content' field as analyzed which enables full text search operations
        Index(x => x.Content, FieldIndexing.Search);

        // storing fields so when projection (e.g. ProjectInto)
        // requests only those fields
        // then data will come from index only, not from storage
        Store(x => x.Id, FieldStorage.Yes);
        Store(x => x.DisplayName, FieldStorage.Yes);
        Store(x => x.Collection, FieldStorage.Yes);
    \}
\}
`}
</CodeBlock>
</TabItem>

and query it using:

<TabItem value="multi_map_1_1" label="multi_map_1_1">
<CodeBlock language="csharp">
{`IList<Smart_Search.Projection> results = session
    .Query<Smart_Search.Result, Smart_Search>()
    .Search(x => x.Content, "Lau*")
    .ProjectInto<Smart_Search.Projection>()
    .ToList();

foreach (Smart_Search.Projection result in results)
\{
    Console.WriteLine(result.Collection + ": " + result.DisplayName);
    // Companies: Laughing Bacchus Wine Cellars
    // Products: Laughing Lumberjack Lager
    // Employees: Laura Callahan
\}
`}
</CodeBlock>
</TabItem>

## Remarks

<Admonition type="info" title="">
Remember that all map functions **must** output objects with **identical** shape (field names have to match).
</Admonition>

