import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import Panel from "@site/src/components/Panel";
import ContentFrame from "@site/src/components/ContentFrame";

<Admonition type="note" title="">

* In this section, we explain how to use [RavenDB.TestDriver](https://www.nuget.org/packages/RavenDB.TestDriver/) 
  to write RavenDB unit tests.  

* TestDriver uses an [Embedded Server](../../server/embedded.mdx) package with the same set of 
  [prerequisites](../../server/embedded.mdx#prerequisite) as embedded servers to run the tests.  

* In this page: 
   - [`RavenTestDriver`](../../start/test-driver.mdx#raventestdriver)
   - [Pre-initializing the store: `PreInitialize`](../start/test-driver#pre-initializing-the-store-preinitialize)
   - [Configure the server: `ConfigureServer`](../start/test-driver#configure-the-server-configureserver)
   - [Unit test](../../start/test-driver.mdx#unit-test)
   - [Complete example](../../start/test-driver.mdx#complete-example)
   - [Continuous Integration (CI) Servers](../start/test-driver#continuous-integration-ci-servers)
   - [Licensing](../../start/test-driver.mdx#licensing)

</Admonition>

<Panel heading="RavenTestDriver">

Start by creating a class that derives from `RavenTestDriver`.  
Find below a list of test driver methods, followed by [samples](../../start/test-driver.mdx#complete-example).  

### TestDriver Methods

<ContentFrame>
#### `DatabaseDumpFilePath`
Override the path to the database dump file that is loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual string DatabaseDumpFilePath => null;
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `DatabaseDumpFileStream`
Allow overriding the stream containing the database dump loaded when calling ImportDatabase.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual Stream DatabaseDumpFileStream => null;
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `GetDocumentStore`
Get an IDocumentStore instance for the requested database.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public IDocumentStore GetDocumentStore([CallerMemberName] string database = null, 
                                                TimeSpan? waitForIndexingTimeout = null)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>  
<ContentFrame>

#### `PreInitialize`
Pre-initialize IDocumentStore.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreInitialize(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `PreConfigureDatabase`
Pre configure the database record before creating it.  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void PreConfigureDatabase(DatabaseRecord databaseRecord)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `SetupDatabase`
Initialize the database  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void SetupDatabase(IDocumentStore documentStore)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `DriverDisposed`  
An event raised when the test driver is disposed of  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected event EventHandler DriverDisposed;
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `ConfigureServer`  
Configure the server before running it
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public static void ConfigureServer(TestServerOptions options)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `WaitForIndexing`
Wait for indexes to become non-stale  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForIndexing(IDocumentStore store, string database = null, 
                                                    TimeSpan? timeout = null)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `WaitForUserToContinueTheTest`  
Pause the test and launch Studio to examine database state  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public void WaitForUserToContinueTheTest(IDocumentStore store)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `OpenBrowser`  
Open browser  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`protected virtual void OpenBrowser(string url)
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
<ContentFrame>

#### `Dispose`  
Dispose of the server  
<TabItem value="csharp" label="csharp">
<CodeBlock language="csharp">
{`public virtual void Dispose()
`}
</CodeBlock>
</TabItem>  

</ContentFrame>
</Panel>

<Panel heading="Pre-initializing the store: `PreInitialize`">

Pre-Initializing the IDocumentStore allows you to mutate the conventions used by the document store.

### Example

<TabItem value="test_driver_PreInitialize" label="test_driver_PreInitialize">
<CodeBlock language="csharp">
{`//This allows us to modify the conventions of the store we get from 'GetDocumentStore'
protected override void PreInitialize(IDocumentStore documentStore)
\{
    documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
\}
`}
</CodeBlock>
</TabItem>

</Panel>

<Panel heading="Configure the server: `ConfigureServer`">

The `ConfigureServer` method allows you to be more in control of your server.  
You can use it with `TestServerOptions` to change the path to the Raven server binaries, specify data storage path, adjust .NET framework versions, etc.

* `ConfigureServer` can only be set once per test run.  
  It needs to be set before `GetDocumentStore` is called.  
  See an [example](../../start/test-driver.mdx#complete-example) below.  

* If it is called twice, or within the `DocumentStore` scope, you will get the following error message:
  `System.InvalidOperationException : Cannot configure server after it was started. Please call 'ConfigureServer' method before any 'GetDocumentStore' is called.`  

<Admonition type="info" title="TestServerOptions" id="testserveroptions" href="#testserveroptions">

Defining TestServerOptions allows you to be more in control of 
how the embedded server is going to run with just a minor [definition change](../../start/test-driver.mdx#example-2).

* To see the complete list of `TestServerOptions`, which inherits from embedded servers, go to embedded [ServerOptions](../../server/embedded.mdx#serveroptions).  
* It's important to be sure that the correct [.NET FrameworkVersion](../../server/embedded.mdx#net-frameworkversion) is set.

</Admonition>

<ContentFrame>
#### Example

<TabItem value="test_driver_ConfigureServer" label="test_driver_ConfigureServer">
<CodeBlock language="csharp">
{`var testServerOptions = new TestServerOptions
\{
    // Looks for the newest version on your machine including 3.1.15 and any newer patches
    // but not major new releases (default is .NET version at time of server release).
    FrameworkVersion = "3.1.15+",

    // Specifies where ravendb server binaries are located (Optional)
    ServerDirectory = "PATH_TO_RAVENDB_SERVER",

    // Specifies where ravendb data will be placed/located (Optional)
    DataDirectory = "PATH_TO_RAVENDB_DATADIR", 
\};

ConfigureServer(testServerOptions);
`}
</CodeBlock>
</TabItem>
</ContentFrame>
</Panel>

<Panel heading="Unit test">

We use [xunit](https://www.nuget.org/packages/xunit/) for the test framework in the below example.  

<Admonition type="note" title="">
Note that the test itself is meant to show different capabilities of the test driver and is not meant to be the most efficient.  
</Admonition>

The example below depends on the `TestDocumentByName` index and `TestDocument` class that can be seen in the [full example](../../start/test-driver.mdx#complete-example)

<ContentFrame>
#### Example

In the example, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', and we assert that we have only one such document.

<TabItem value="test_driver_MyFirstTest" label="test_driver_MyFirstTest">
<CodeBlock language="csharp">
{`[Fact]
public void MyFirstTest()
\{
    using (var store = GetDocumentStore())
    \{
        store.ExecuteIndex(new TestDocumentByName());
        using (var session = store.OpenSession())
        \{
            session.Store(new TestDocument \{ Name = "Hello world!" \});
            session.Store(new TestDocument \{ Name = "Goodbye..." \});
            session.SaveChanges();
        \}
        // If we want to query documents, sometimes we need to wait for the indexes to catch up  
        // to prevent using stale indexes.
        WaitForIndexing(store);

        // Sometimes we want to debug the test itself. This method redirects us to the studio
        // so that we can see if the code worked as expected (in this case, created two documents).
        WaitForUserToContinueTheTest(store);

        using (var session = store.OpenSession())
        \{
            var query = session.Query<TestDocument, TestDocumentByName>().Where(x => x.Name == "hello").ToList();
            Assert.Single(query);
        \}
    \}
\}
`}
</CodeBlock>
</TabItem>
</ContentFrame>

</Panel>
<Panel heading="Complete example">

This is a full unit test using [Xunit](https://www.nuget.org/packages/xunit/).

In the test, we get an `IDocumentStore` object to our test database, deploy an index, and insert two documents into the document store.  

We then use `WaitForUserToContinueTheTest(store)` which launches the Studio so we can verify that the documents 
and index are deployed (we can remove this line after the test succeeds).  

Finally, we use `session.Query` to query for "TestDocument" where the name contains the word 'hello', and we assert that we have only one such document.

<TabItem value="test_full_example" label="test_full_example">
<CodeBlock language="csharp">
{`using Raven.Client.Documents;
using Raven.TestDriver;
using Xunit;
using System.Linq;
using Raven.Client.Documents.Indexes;

namespace RavenDBTestDriverFullExample
\{

    public class RavenDBTestDriver : RavenTestDriver
    \{
        static RavenDBTestDriver()
        \{
            // ConfigureServer() must be set before calling GetDocumentStore()
            // and can only be set once per test run.
            ConfigureServer(new TestServerOptions
            \{
                DataDirectory = "C:\\\\RavenDBTestDir"
            \});
        \}
        // This allows us to modify the conventions of the store we get from 'GetDocumentStore'
        protected override void PreInitialize(IDocumentStore documentStore)
        \{
            documentStore.Conventions.MaxNumberOfRequestsPerSession = 50;
        \}

        [Fact]
        public void MyFirstTest()
        \{
            // GetDocumentStore() evokes the Document Store, which establishes and manages communication
            // between your client application and a RavenDB cluster via HTTP requests.
            using (var store = GetDocumentStore())
            \{
                store.ExecuteIndex(new TestDocumentByName());
                using (var session = store.OpenSession())
                \{
                    session.Store(new TestDocument \{ Name = "Hello world!" \});
                    session.Store(new TestDocument \{ Name = "Goodbye..." \});
                    session.SaveChanges();
                \}
                // If we want to query documents, sometimes we need to wait for the indexes to catch up  
                // to prevent using stale indexes.
                WaitForIndexing(store);

                // Sometimes we want to debug the test itself. This method redirects us to the studio
                // so that we can see if the code worked as expected (in this case, created two documents).
                WaitForUserToContinueTheTest(store);

                // Queries are defined in the session scope.
                // If there is no relevant index to quickly answer the query, RavenDB creates an auto-index
                // based on the query parameters.
                // This query will use the static index defined in lines 63-70 and filter the results by name.
                using (var session = store.OpenSession())
                \{
                    var query = session.Query<TestDocument, TestDocumentByName>()
                        .Where(x => x.Name == "hello").ToList();
                    Assert.Single(query);
                \}
            \}
        \}
    \}
    // AbstractIndexCreationTask allows you to create and manually define a static index. 
    public class TestDocumentByName : AbstractIndexCreationTask<TestDocument>
    \{
        public TestDocumentByName()
        \{
            Map = docs => from doc in docs select new \{ doc.Name \};
            Indexes.Add(x => x.Name, FieldIndexing.Search);
        \}
    \}

    public class TestDocument
    \{
        public string Name \{ get; set; \}
    \}
\}
`}
</CodeBlock>
</TabItem>
</Panel>

<Panel heading="Continuous Integration (CI) Servers">

Best practice is to use a CI/CD server to help automate the testing and deployment of your new code. 
Popular CI/CD products are [AppVeyor](https://www.appveyor.com/) or [Visual Studio Team Services (aka. VSTS)](https://visualstudio.microsoft.com/team-services/).

</Panel>

<Panel heading="Licensing">

The embedded server that TestDriver uses while running your tests can only apply the features and access the resources defined by its [license](https://ravendb.net/buy).  
E.g., an unlicensed server will be able to use no more than 3 CPU cores, while a server with a [free developers license](https://ravendb.net/buy#developer) will be able to use up to 9 cores and run way faster.  

* When the server is started, its license is validated.  
   * If the validation succeeds, the server will run, applying the capabilities defined by its license.  
   * If the validation fails, the server may still run - but its capabilities will be limited to those defined by the basic [AGPL](https://ravendb.net/legal/ravendb/commercial-license-eula) license (e.g., using up to 3 CPU cores).  
     <Admonition type="note" title="">
     If the validation fails because the license expired, and the expiration date precedes the server build date, the server will not run.  
     </Admonition>

* A `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` configuration option is available since RavenDB `5.4`, determining whether to throw a `LicenseExpiredException` exception if TestDriver uses an unlicensed embedded server.  
   * If `ThrowOnInvalidOrMissingLicense` is set to **`true`** and the validation fails, a `LicenseExpiredException` exception will be thrown to **warn TestDriver users** that in lack of a valid license, their server's capabilities are limited and they may therefore miss out on much of their system's potential.  
   * If the configuration option is set to **`false`**, **no exception will be thrown** even if a license cannot be validated.  
   * Since RavenDB version `6.2`, `TestServerOptions.Licensing.ThrowOnInvalidOrMissingLicense` is set by default to `true` so a `LicenseExpiredException` exception **would** be thrown if the embedded server used by TestDriver fails to validate a license.  
     Users that prefer that no exception would be thrown if an unlicensed embedded server is used, can explicitly set the configuration option to **`false`**.  

* Read about additional licensing configuration options in the [Embedded server page](../server/embedded#embedded-server-licensing) licensing section.  

</Panel>
