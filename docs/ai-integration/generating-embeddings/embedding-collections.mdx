---
title: "The Embedding Collections"
hide_table_of_contents: true
sidebar_label: The Embedding Collections
sidebar_position: 3
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# The Embedding Collections
<Admonition type="note" title="">

* The embeddings generated by the providers are stored as **attachments** in your database.  
  Each attachment contains a single embedding.

* The server creates the following dedicated collections,  
  which contain documents that reference the embedding attachments:  
  * **Embeddings Collections**
  * **Embeddings Cache Collection**

* This article describes these custom-designed collections.  
  It is recommended to first refer to this [Overview](../../ai-integration/generating-embeddings/overview.mdx#embeddings-generation---overview)
  to understand the embeddings generation process flow.
* In this article:
    * [The embeddings collections](../../ai-integration/generating-embeddings/embedding-collections.mdx#the-embeddings-collections)
    * [The embeddings cache collection](../../ai-integration/generating-embeddings/embedding-collections.mdx#the-embeddings-cache-collection)
    
</Admonition>
## The embeddings collections

* RavenDB creates a separate embeddings collection for each source collection from which embeddings are generated.
  The naming format for these collections is: `@embeddings/<source-collection-name>`.

* Each document in the embeddings collection references ALL embeddings generated from
  the content of the corresponding document in the source collection by any defined embeddings generation task.

* The document structure in the embeddings collection is:

<TabItem value="json" label="json">
<CodeBlock language="json">
{`\{
  "identifier-of-task-1": \{
     "@quantization": "<quantization-type>",
     "Property1": [
       "Hash of the embedding vector generated for 1st text chunk of Property1's content",
       "Hash of the embedding vector generated for 2nd text chunk of Property1's content",   
       "Hash of the embedding vector generated for 3rd text chunk of Property1's content", 
       "..."
     ],
     "Property2": [
       "Hash of the embedding vector generated for 1st text chunk of Property2's content",
       "..."
     ]
  \},
  "identifier-of-task-2": \{
    "Property3": [
      "Hash of the embedding vector generated for 1st text chunk of Property3's content",
      "..."
    ]
  \},
  "Other-tasks...": \{
     ...
  \},
  "@metadata": \{
     "@collection": "<source-collection-name>/embeddings",
     "@flags": "HasAttachments"
  \}
\}
`}
</CodeBlock>
</TabItem>
* For example:  
  In this [task definition](../../ai-integration/generating-embeddings/embeddings-generation-task.mdx#configuring-an-embeddings-generation-task---from-the-studio),
  an embeddings generation task is defined on the `Categories` collection.  
  This creates the `@embeddings/Categories` collection, where a document will look as follows:

    ![The embeddings document](./assets/embeddings-collection-1.png)

  1. **Collection name**   
     The unique name of the embeddings collection: `@embeddings/Categories`.
  2. **Document ID**  
     Each document ID in this collection follows the format: `embeddings/<source-document-name>`  
  3. **Task identifier**  
     The identifier of the task that generated the embeddings for the listed properties.
  4. **Quantization type**  
     The quantization method applied by the task when generating the embeddings.  
  5. **Source properties & their hashes**:  
     This section contains properties from the source document whose content was converted into embeddings.  
     Each property holds an array of Base64 hashes.
     Each hash is derived from the content of an embedding vector generated for a text chunk from the property's content:  
     `<property-name>: [`  
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<hash-of-the-embedding-vector-for-text-chunk-1>,`  
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`<hash-of-the-embedding-vector-for-text-chunk-2>,`  
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`...`  
     `]`  
  6. **Attachment flag**  
     Indicates that the document includes attachments, which store the embeddings.  
     The next image shows the embedding attachments in the document's properties pane.

    ![The embeddings document - attachments](./assets/embeddings-collection-2.png)

  * Each attachment contains a **single embedding**.

  * The **attachment name** is the Base64 hash derived from the content of the embedding vector stored in the attachment:  
    `<hash-of-the-embedding-vector-content>`



## The embeddings cache collection

<Admonition type="note" title="">

####  Cache contents
* In addition to creating embeddings collections for each source collection,  
  RavenDB creates and maintains a single **embeddings cache collection** named: `@embeddings-cache`.

* This cache collection contains embeddings generated by all providers,  
  both from source documents and from search terms used in vector search queries.

* Each document in the `@embeddings-cache` collection references a **single attachment** that contains a single embedding vector.
  **The document ID includes**:  
  * The [connection string identifier](../../ai-integration/connection-strings/connection-strings-overview.mdx#creating-an-ai-connection-string),
    which specifies the provider and model that generated the embedding.
  * A Base64 hash generated from a text chunk value - either from a source document property or from a search term.
  * If the embedding was quantized by the task, the document ID also includes the quantization type.

</Admonition>
<Admonition type="note" title="">

#### Cache lookup  
* Before making a request to a text embedding provider, 
  RavenDB first checks the `@embeddings-cache` collection to determine whether an embedding for the given input already exists from the same provider.  

* This applies both when generating embeddings for source document content and when performing a vector search that requires an embedding for the search term.  

* To find a matching embedding, RavenDB:  
   1. **Generates a hash** from the chunked text content that requires embedding.  
   2. **Identifies the provider** the user is working with, based on the specified connection string.  
   3. **Compares these values** (the connection string identifier and the hash) with those stored in the cache collection.  
      (Each document in `@embeddings-cache` has an ID that includes these two components).  
   4. If a document with a matching ID exists in the cache,  
      RavenDB **retrieves the corresponding embedding** instead of generating a new one.  

</Admonition>
<Admonition type="note" title="">

####  Cache performance benefits
* **Reduced latency**:  
  Reusing cached embeddings eliminates the need for additional provider requests, improving response time.  

* **Lower provider costs**:  
  Since embedding providers often charge per request, caching prevents redundant calls and reduces expenses.  

* **Optimized vector search**:  
  If a cached embedding exists for the search term in the query, the search runs faster by skipping unnecessary processing.  

</Admonition>
<Admonition type="note" title="">

#### Expiration policy
* **The expiration date**:  
  Each document in this cache collection is created with an expiration date, which is set according to the expiration period defined in the embeddings generation task.
  Once the expiration date is reached, the document is automatically deleted (provided that [document expiration](../../studio/database/settings/document-expiration.mdx) is enabled).

* **Extending the expiration period**:  
  * When a source document (from which embeddings were generated) is modified - even if the change is not to a property used for embeddings -
    RavenDB checks the expiration of the matching document in the cache collection.
    If the remaining time is less than half of the original duration, RavenDB extends the expiration by the period defined in the task.
  * When you make a vector search query and an embedding generated from a chunk of the search term already exists in the cache,
    RavenDB also extends the expiration of the matching document by the period defined in the query settings of the embeddings generation task.

</Admonition>
* **The @embeddings-cache collection**: 

    ![The embeddings cache - list](./assets/embeddings-cache-1.png)

  1. **Collection name**  
     The name of the embeddings cache collection: `@embeddings-cache`.  
  
  2. **Connection string identifier**  
     The document ID includes the connection string identifier, which specifies the provider that generated the embedding.

  3. **Hash**  
     The document ID includes a Base64 hash created from a text chunk -  
     either from a source document property or from a search term in a vector search query.
* **A document in the @embeddings-cache collection**:  
 
    ![The embeddings cache - document](./assets/embeddings-cache-2.png)

  1. **Document ID**  
     The document ID follows this format:  
     `embeddings-cache/<connection-string-identifier>/<hash-of-text-chunk-from-property-or-search-term>`
        
        If the embedding was [quantized](../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#what-is-quantization) by the task
        using a type other than _Single_ (e.g., _Int8_ or _Binary_),  
        the ID format includes the quantization type:  
        `embeddings-cache/<connection-string-identifier>/<hash-of-text-chunk-from-property-or-search-term>/<quantization-type>`
 
   2. **Expiration time**  
      The document is removed when the expiration time is reached.
* **The embedding attachment**:

    ![The embeddings cache - attachments](./assets/embeddings-cache-3.png)

    * The name of the attachment is the hash string:  
      `<hash-of-text-chunk-from-property-or-search-term>`



