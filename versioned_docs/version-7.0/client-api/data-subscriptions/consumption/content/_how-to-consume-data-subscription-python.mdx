import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Batches of documents sent from a Subscription Task defined on the server are consumed and processed by a subscription worker client.  
 
* The `subscription_worker` object, defined on the client, manages the communication between the server and the client and processes the document batches sent from the server.  
 
* There are several ways to create and configure the SubscriptionWorker - see `SubscriptionWorkerOptions`.  

* In this page:
  * [`subscription_worker` lifecycle](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#subscription_worker-lifecycle)  
  * [Error handling](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#error-handling)  
  * [Worker strategies](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#worker-strategies)
  * [Determining which workers a subscription will serve](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#determining-which-workers-a-subscription-will-serve)  

</Admonition>
## `subscription_worker` lifecycle

A `subscription_worker` object starts its life from being generated by the `store.subscriptions`:
<TabItem value="subscription_open_simple" label="subscription_open_simple">
<CodeBlock language="python">
{`subscription_worker = store.subscriptions.get_subscription_worker_by_name(subscription_name, Order)
`}
</CodeBlock>
</TabItem>

At this point, the worker has only got its configuration. No connection or processing happens at this moment.  
To start processing, the `run` method should be called. The Run method receives the batch processing logic that should be performed:
<TabItem value="subscription_run_simple" label="subscription_run_simple">
<CodeBlock language="python">
{`subscription_runtime_task = subscription_worker.run(
    process_documents=lambda batch: ...
)  # Pass your method that takes SubscriptionBatch[_T] as an argument, with your logic in it
`}
</CodeBlock>
</TabItem>

From this point on, the subscription worker will start processing batches.  
If processing is aborted for any reason, the returned task (`subscription_runtime_task`) will complete with an exception.  



## Error handling

<Admonition type="info" title="Subscription worker connection failures" id="subscription-worker-connection-failures" href="#subscription-worker-connection-failures">

Subscription worker connection failures may occur during the routine communication between the worker and the server.
When an unexpected error arises, the worker will attempt to **reconnect to the server**.

However, there are several conditions under which the worker will stop its operation but will Not attempt to reconnect:

* The subscription no longer exists or has been deleted.
* Another worker has taken control of the subscription (see [connection strategy](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#available-worker-strategies)).
* The worker is unable to connect to any of the servers.
* The worker could not receive the node responsible for the task  
  (this can happen when there is no leader in the cluster).
* An authorization exception occurred.
* An exception occurred during the connection establishment phase.
* The database doesn't exist.

</Admonition>

<Admonition type="info" title="Batch processing execution failures" id="batch-processing-execution-failures" href="#batch-processing-execution-failures">

An exception may occur while processing a batch of documents in the worker.
For example:

<TabItem value="throw_during_user_logic" label="throw_during_user_logic">
<CodeBlock language="python">
{`def _throw_exception(batch: SubscriptionBatch):
    raise Exception()

_ = worker_w_batch.run(_throw_exception)
`}
</CodeBlock>
</TabItem>

When creating a worker, the worker can be configured to handle these exceptions in either of the following ways,
depending on the `ignore_subscriber_errors` property in [SubscriptionWorkerOptions](../../../../client-api/data-subscriptions/consumption/api-overview.mdx#subscriptionworkeroptions):

* **Abort processing completely**  
  When `ignore_subscriber_errors` is set to _false_ (default):  
  The current batch processing will be aborted, and in this case, the worker will wrap the thrown exception in a `SubscriberErrorException` and will rethrow it.
  Processing of the subscription will be terminated without acknowledging progress to the server or retrying to connect.  
  As a result, the task returned by the `Run` function will complete in an erroneous state, throwing a _SubscriberErrorException_.

* **Continue processing subsequent batches**  
  When `ignore_subscriber_errors` is set to _true_:    
  The current batch processing will be aborted; however, the erroneous batch will be acknowledged without retrying,
  and processing will continue with the next batches.

</Admonition>

<Admonition type="info" title="Reconnecting" id="reconnecting" href="#reconnecting">

Two properties in the [SubscriptionWorkerOptions](../../../../client-api/data-subscriptions/consumption/api-overview.mdx#subscriptionworkeroptions)
object control the behavior of a worker attempting to reconnect with the server:

* `time_to_wait_before_connection_retry`  
  The time the worker will wait before attempting to reconnect.  
  Default: 5 seconds.
* `max_erroneous_period`  
  The maximum amount of time the subscription connection can remain in an erroneous state.   
  Once this period is exceeded, the worker will stop trying to reconnect.  
  Default: 5 minutes.  

</Admonition>

<Admonition type="info" title="`on_unexpected_subscription_error`" id="on_unexpected_subscription_error" href="#on_unexpected_subscription_error">

`on_unexpected_subscription_error` is the event that is triggered when a connection failure occurs between the subscription worker and the server,
resulting in an unexpected exception.  
When this happens, the worker will automatically attempt to reconnect.  
This event is useful for logging these unexpected exceptions.

</Admonition>



## Worker strategies

Subscription workers are configured with a **strategy** that determines whether multiple workers
can connect to the subscription concurrently or if only one worker can connect at a time.

The _one-worker-at-a-time_ strategy also determines how the workers interact with each other
to resolve which will establish the subscription connection.
### One worker per subscription strategies

The following three strategies allow only a **single worker to connect to the subscription at any given time**,  
and determine what happens when one worker is connected and another tries to connect.

* `SubscriptionOpeningStrategy.OPEN_IF_FREE`  
  The server will allow a worker to connect only if no other worker is currently connected.  
  If there is an existing connection, the incoming worker will throw a `SubscriptionInUseException`.
* `SubscriptionOpeningStrategy.WAIT_FOR_FREE`  
  If the worker cannot open the subscription because it is in use by another worker, it will wait for the currently connected worker to disconnect before establishing the connection.
  This is useful in worker failover scenarios, where one worker is connected while another is awaiting its turn to take its place.
* `SubscriptionOpeningStrategy.TAKE_OVER`  
  The server will allow an incoming connection to take over an existing one,  
  based on the connection strategy in use by the currently connected worker:
    * If the existing connection **does not** have a `TAKE_OVER` strategy:  
      The incoming connection will take over, causing the existing connection to throw a `SubscriptionInUseException`.
    * If the existing connection **has** a `TAKE_OVER` strategy:  
      The incoming connection will throw a `SubscriptionInUseException` exception.
### Multiple workers per subscription strategy

* `SubscriptionOpeningStrategy.CONCURRENT`  
  The server allows multiple workers to connect to the same subscription **concurrently**.  
  Read more about concurrent subscriptions [here](../../../../client-api/data-subscriptions/concurrent-subscriptions.mdx).



## Determining which workers a subscription will serve

<Admonition type="note" title="">

The **strategy used by the first worker connecting to a subscription** determines
which additional workers the subscription can serve until all worker connections are dropped.

</Admonition>

* A subscription that serves one or more [CONCURRENT](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#multiple-workers-per-subscription-strategy) workers, 
  **can only serve other concurrent workers** until all connections are dropped. 
  If a worker with a [one worker per subscription](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#one-worker-per-subscription-strategies) 
  strategy attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  

* A subscription that serves a worker with a [one worker per subscription](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#one-worker-per-subscription-strategies) strategy, 
  **cannot** serve [CONCURRENT](../../../../client-api/data-subscriptions/consumption/how-to-consume-data-subscription.mdx#multiple-workers-per-subscription-strategy) 
  workers until that worker's connection is dropped. 
  If a concurrent worker attempts to connect -  
   * The connection attempt will be rejected.  
   * `SubscriptionInUseException` will be thrown.  




