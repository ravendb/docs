import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">
    
* **Atomic Guards** are [compare-exchange key/value items](../compare-exchange/overview)
  that RavenDB creates and manages **automatically** to guarantee [ACID](../server/clustering/cluster-transactions#cluster-transactions-properties) behavior in cluster-wide sessions.  
  
* When a document is created in a cluster-wide session, RavenDB associates it with a unique atomic guard item.  
  Atomic guards coordinate concurrent writes by different sessions to the same document.

* In this article:
  * [Atomic guard creation and update](../compare-exchange/atomic-guards#atomic-guard-creation-and-update)
  * [Atomic guard usage example](../compare-exchange/atomic-guards#atomic-guard-creation-and-update)
  * [Atomic guard database scope](../compare-exchange/atomic-guards#atomic-guard-database-scope)  
  * [Disabling atomic guards](../compare-exchange/atomic-guards#disabling-atomic-guards)  
  * [When are atomic guards removed](../compare-exchange/atomic-guards#when-are-atomic-guards-removed)  
  * [Best practice when storing a document in a cluster-wide transaction](../compare-exchange/atomic-guards#best-practice-when-storing-a-document-in-a-cluster-wide-transaction)  

</Admonition>

---

## Atomic guard creation and update

<Admonition type="info" title="">
Atomic guards are created and managed **only when the session's transaction mode is set to [ClusterWide](../client-api/session/cluster-transaction/overview#open-a-cluster-transaction)**.
</Admonition>

* **When creating a new document**:  
  A new atomic guard is created when a new document is successfully saved.

* **When modifying an existing document that already has an atomic guard**: 
  * The atomic guard’s Raft index is incremented when the document is successfully saved after being modified.  
    This allows RavenDB to detect that the document has changed.
  * If another session had loaded the document before the document's version changed, it will not be able to save its changes
    unless it first reloads the updated version. Otherwise, a `ConcurrencyException` is thrown.

* **When modifying an existing document that doesn't have an atomic guard**:  
  * A new atomic guard is created when modifying an existing document that does not yet have one.
  * The absence of the atomic guard may be because the document was created in a single-node session,  
    or because its atomic guard was manually removed (which is not recommended).

* **When saving a document fails**:  
  * If a session's `SaveChanges()` fails, the entire session is rolled back and the atomic guard is Not created.  
  * Ensure your business logic is designed to re-execute the session in case saving changes fails for any reason.

---

## Atomic guard usage example

In the code sample below, an atomic guard is automatically created when a new document is saved.  
It is then used to detect and prevent conflicting writes: when two sessions load and modify the same document,  
only the first save succeeds, and the second fails with a _ConcurrencyException_.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync_session" label="Sync_session">
```csharp
using (var session = store.OpenSession(new SessionOptions
{
           // Open a cluster-wide session:
           TransactionMode = TransactionMode.ClusterWide
}))
{
    session.Store(new User(), "users/johndoe");
    session.SaveChanges();
    // An atomic guard is now automatically created for the new document "users/johndoe".
}

// Open two concurrent cluster-wide sessions:
using (var session1 = store.OpenSession(
           new SessionOptions 
               {TransactionMode = TransactionMode.ClusterWide}))
using (var session2 = store.OpenSession(
           new SessionOptions 
               {TransactionMode = TransactionMode.ClusterWide}))
{
    // Both sessions load the same document:
    var loadedUser1 = session1.Load<User>("users/johndoe");
    loadedUser1.Name = "jindoe";

    var loadedUser2 = session2.Load<User>("users/johndoe");
    loadedUser2.Name = "jandoe";

    // session1 saves its changes first —
    // this increments the Raft index of the associated atomic guard.
    session1.SaveChanges();

    // session2 tries to save using an outdated atomic guard version
    // and fails with a ConcurrencyException.
    session2.SaveChanges();
}
```
</TabItem>
<TabItem value="Async_session" label="Async_session">
```csharp
using (var asyncSession = store.OpenAsyncSession(new SessionOptions
{
     // Open a cluster-wide session:
     TransactionMode = TransactionMode.ClusterWide
}))
{
    await asyncSession.StoreAsync(new User(), "users/johndoe");
    await asyncSession.SaveChangesAsync();
    // An atomic guard is now automatically created for the new document "users/johndoe".
}

// Open two concurrent cluster-wide sessions:
using (var asyncSession1 = store.OpenAsyncSession(
       new SessionOptions 
       {TransactionMode = TransactionMode.ClusterWide}))
using (var asyncSession2 = store.OpenAsyncSession(
       new SessionOptions 
       {TransactionMode = TransactionMode.ClusterWide}))
{
    // Both sessions load the same document:
    var loadedUser1 = await asyncSession1.LoadAsync<User>("users/johndoe");
    loadedUser1.Name = "jindoe";

    var loadedUser2 = await asyncSession2.LoadAsync<User>("users/johndoe");
    loadedUser2.Name = "jandoe";

    // asyncSession1 saves its changes first —
    // this increments the Raft index of the associated atomic guard.
    await asyncSession1.SaveChangesAsync();

    // asyncSession2 tries to save using an outdated atomic guard version
    // and fails with a ConcurrencyException.
    await asyncSession2.SaveChangesAsync();
}
```
</TabItem>
</Tabs>

After running the above example, you can view the automatically created atomic guard in the **Compare-Exchange view**  
in the Studio:

![Atomic Guard](../assets/atomic-guard.png)

1. These are **custom compare-exchange items**, created by the user for any purpose,  
   as described in [Create compare-exchange items](../compare-exchange/create-cmpxchg-items).
   They are NOT the automatically created atomic guards.

2. This is the **atomic guard** that was generated by running the example above.  
   The generated atomic guard **key** is: `rvn-atomic/users/johndoe`. It is composed of:  
     * The prefix `rvn-atomic/`.
     * The ID of the associated document (`users/johndoe`).

<Admonition type="warning" title="">
 * Although this Studio view allows editing compare-exchange items, **do NOT delete or modify atomic guard entries**.
 * Doing so will interfere with RavenDB's ability to track document versioning through atomic guards.
</Admonition>

---

## Atomic guard database scope

* Atomic guards are local to the database on which they were defined.

* Since atomic guards are implemented as compare-exchange items,  
  they are Not externally replicated to other databases by any ongoing replication task.  
  Learn more in [why compare-exchange items are not replicated](../compare-exchange/overview#why-compare-exchange-items-are-not-replicated-to-external-databases).

---

## Disabling atomic guards

* Before atomic guards were introduced (in RavenDB 5.2), client code had to explicitly manage compare-exchange entries
  to ensure concurrency control and maintain ACID guarantees in cluster-wide transactions.

* You can still take this manual approach by disabling the automatic use of atomic guards in a cluster-wide session,
  and managing the required [compare-exchange key/value pairs](../compare-exchange/overview) yourself,
  as shown in this [example](../compare-exchange/overview#example-i---email-address-reservation).

* To disable the automatic creation and use of atomic guards in a cluster-wide session,
  set the session's `DisableAtomicDocumentWritesInClusterWideTransaction` configuration option to `true`.

<Tabs groupId='languageSyntax'>
<TabItem value="Sync_session" label="Sync_session">
```csharp
using (var session = store.OpenSession(new SessionOptions
{
     TransactionMode = TransactionMode.ClusterWide,
     // Disable atomic-guards
     DisableAtomicDocumentWritesInClusterWideTransaction = true
}))
{
    session.Store(new User(), "users/johndoe");

    // No atomic-guard will be created upon saveChanges
    session.SaveChanges();
}
```
</TabItem>
<TabItem value="Async_session" label="Async_session">
```csharp
using (var asyncSession = store.OpenAsyncSession(new SessionOptions
{
     TransactionMode = TransactionMode.ClusterWide,
     // Disable atomic-guards
     DisableAtomicDocumentWritesInClusterWideTransaction = true
}))
{
    await asyncSession.StoreAsync(new User(), "users/johndoe");

    // No atomic-guard will be created upon saveChanges
    await asyncSession.SaveChangesAsync();
}
```
</TabItem>
</Tabs>

---

## When are atomic guards removed

Atomic guards are removed **automatically** in the following scenarios:  
(you don't need to clean them up manually)

* **Document deleted via a cluster-wide session**:
    * Create a document using a cluster-wide session (an associated atomic guard is created).
    * Delete the document using a cluster-wide session - its atomic guard will be removed automatically.

* **Document expires via the expiration feature**:
    * Create a document using a cluster-wide session (an associated atomic guard is created).
    * Add the `@expires` metadata property the document, as described in [Document expiration](../studio/database/settings/document-expiration).
    * When the expiration time is reached, the document and its atomic guard will both be removed automatically.
    * Since different cleanup tasks handle the removal of **expired** documents and the removal of their associated atomic guards,
      it may happen that atomic guards of removed documents would linger in the compare-exchange entries list a short while longer before they are removed.
      You do Not need to remove such atomic guards yourself, they will be removed by the cleanup task.

<Admonition type="warning" title="">

* **Do not delete or modify atomic guards manually**.  
  If a session attempts to save a document whose atomic guard was removed or modified, it will fail with an error.
 
* If you accidentally remove an atomic guard that is associated with an existing document,  
  you can restore it by re-saving the document in a cluster-wide session,  
  this will re-create the atomic guard automatically.

</Admonition>

---

## Best practice when storing a document in a cluster-wide transaction

* When working with a cluster-wide session,  
  we recommend that you always **`Load` the document into the session before storing it** -  
  even if the document is expected to be new.

* This is especially important if a document (originally created in a cluster-wide transaction) was deleted **outside** of a cluster-wide session -
  as when using a [single-node session](../client-api/session/cluster-transaction/overview#cluster-wide-transaction-vs-single-node-transaction)
  or the [DeleteByQueryOperation](../client-api/operations/common/delete-by-query).  
  In these cases, the document is deleted, but the atomic guard remains (it is not automatically removed).  
  If you attempt to re-create such a document without loading it first,
  RavenDB will fail to save it because the session is unaware of the existing atomic guard’s latest Raft index.
  
* In this example, the document is loaded into the session BEFORE creating or modifying it:

<Tabs groupId='languageSyntax'>
<TabItem value="Sync_session" label="Sync_session">
```csharp
using (var session = store.OpenSession(new SessionOptions
{
    // Open a cluster-wide session
    TransactionMode = TransactionMode.ClusterWide
}))
{
    // Load the user document BEFORE creating a new one or modifying if already exists
    var user = session.Load<User>("users/johndoe");
    
    if (user == null)
    {
        // Document doesn't exist => create a new document:
        var newUser = new User
        {
            Name = "John Doe",
            // ... initialize other properties
        };

        // Store the new user document in the session
        session.Store(newUser, "users/johndoe");
    }
    else
    {
        // Document exists => apply your modifications:
        user.Name = "New name";
        // ... make any other updates
        
        // No need to call Store() again
        // RavenDB tracks changes on loaded entities
    }

    // Commit your changes
    session.SaveChanges();
}
```
</TabItem>
<TabItem value="Async_session" label="Async_session">
```csharp
using (var asyncSession = store.OpenAsyncSession(new SessionOptions
{
    // Open a cluster-wide session
    TransactionMode = TransactionMode.ClusterWide
}))
{
    // Load the user document BEFORE creating or updating
    var user = await asyncSession.LoadAsync<User>("users/johndoe");
   
    if (user == null)
    {
        // Document doesn't exist => create a new document:
        var newUser = new User
        {
            Name = "John Doe",
            // ... initialize other properties
        };

        // Store the new user document in the session
        await asyncSession.StoreAsync(newUser, "users/johndoe");
    }
    else
    {
        // Document exists => apply your modifications:
        user.Name = "New name";
        // ... make any other updates
        
        // No need to call Store() again
        // RavenDB tracks changes on loaded entities
    }

    // Commit your changes
    await asyncSession.SaveChangesAsync();
}
```
</TabItem>
</Tabs>

<Admonition type="note" title="">

When _loading_ a document in a cluster-wide session, RavenDB attempts to retrieve the document from the document store:

* **If the document is found**, it is loaded into the session,
  and modifications will be saved successfully as long as no other session has modified the document in the meantime.
  Specifically, if the document’s [change vector](../server/clustering/replication/change-vector) matches the one currently stored on the server,
  the save will proceed - after which the Raft index of the associated atomic guard will be incremented as expected.  
  Otherwise, RavenDB will fail the operation with a _ConcurrencyException_.

* **If no document is found**, RavenDB will check whether a matching atomic guard exists (as in the case when the document was deleted outside of a cluster-wide session):
    * **If an atomic guard exists**,
      the client constructs a change vector for the document using the atomic guard’s Raft index, and the document will be saved with this change vector.
    * **If no atomic guard exists**,
      the document is treated as a brand new document and will be saved as usual.

</Admonition>
