import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* This article explains how to index attachments using a **static-index** to enable vector search on their content.  
  Note: Vector search on attachment content is not available when making a [dynamic query](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx).  
  
* **Prior to this article**, refer to the [Vector search using a static index](../../../ai-integration/vector-search/vector-search-using-static-index.mdx) article for general knowledge about  
  indexing a vector field.

* In this article:
    * [Overview](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#overview)
    * [Indexing TEXT attachments](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#indexing-text-attachments)
    * [Indexing NUMERICAL attachments](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#indexing-numerical-attachments)
      * [LINQ index](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#linq-index)
      * [JS index](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#js-index)
    * [Indexing ALL attachments](../../../ai-integration/vector-search/indexing-attachments-for-vector-search.mdx#indexing-all-attachments)

</Admonition>

## Overview

<Admonition type="note" title="">

#### Attachments in RavenDB

* Attachments in RavenDB allow you to associate binary files with your JSON documents.  
  You can use attachments to store images, PDFs, videos, text files, or any other format.  

* Attachments are stored separately from documents, reducing document size and avoiding unnecessary duplication.
  They are stored as **binary data**, regardless of content type.

* Attachments are handled as streams, allowing efficient upload and retrieval.  
  Learn more in: [Attachments overview](../../../document-extensions/attachments/overview.mdx).

</Admonition>

<Admonition type="note" title="">

#### Indexing attachment content for vector search

You can index attachment content in a vector field within a static-index,    
enabling vector search on text or numerical data that is stored in the attachments:

* **Attachments with TEXT**:  
    * During indexing, RavenDB processes the text into a single embedding per attachment using the built-in  
      [bge-micro-v2](https://huggingface.co/TaylorAI/bge-micro-v2) model.

* **Attachments with NUMERICAL data**:  
    * While attachments can store any file type, RavenDB does Not generate embeddings from images, videos, or other non-textual content.  
      Each attachment must contain a **single** precomputed embedding vector, generated externally.  
    * RavenDB indexes the embedding vector from the attachment in and can apply [quantization](../../../ai-integration/vector-search/vector-search-using-dynamic-query.mdx#quantization-options)
      (e.g., index it in _Int8_ format) if this is configured.  
    * All embeddings indexed within the same vector-field in the static-index must be vectors of the **same dimension** to ensure consistency in indexing and search.
      They must also be created using the **same model**.

</Admonition>

## Indexing TEXT attachments
 
* The following index defines a **vector field** named `vectorFromAttachment`.

* It indexes embeddings generated from the text content of the `description.txt` attachment.  
  This applies to all _Company_ documents that contain an attachment with that name.

<Tabs groupId='languageSyntax'>
<TabItem value="Index (C# LINQ)" label="Index (C# LINQ)">
```js
class Companies_ByVector_FromTextAttachment extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // Index-field 'vectorFromAttachment' will hold embeddings
        // generated from the TEXT in the attachments.
        this.map = `docs.Companies.Select(company => new {
            company = company,
            // Load the attachment from the document (ensure it is not null)
            attachment = this.LoadAttachment(company, "description.txt")
        }).Where(this0 => this0.attachment != null).Select(this0 => new {
            // Index the text content from the attachment in the vector field
            vectorFromAttachment = 
                this.CreateVector(this0.attachment.GetContentAsString(Encoding.UTF8))
        })`
    
        // Configure the vector field:
        this.vectorField("vectorFromAttachment", {
            // Specify 'Text' as the source format
            sourceEmbeddingType: "Text", 
            // Specify the desired destination format within the index
            destinationEmbeddingType: "Single"
        })

        this.searchEngineType = "Corax";
    }
}
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```js
const indexDefinition = new IndexDefinition();

indexDefinition.name = "Companies/ByVector/FromTextAttachment";

indexDefinition.maps = [`
    from company in docs.Companies
    
    let attachment = LoadAttachment(company, "description.txt")
    where attachment != null
    
    select new
    {
        vectorFromAttachment = CreateVector(attachment.GetContentAsString(Encoding.UTF8))
    }`]

indexDefinition.fields = {
    "vectorFromAttachment": {
        vector: {
            sourceEmbeddingType: "Text",
            destinationEmbeddingType: "Single"
        }
    }
};

indexDefinition.configuration = {
    "Indexing.Static.SearchEngineType": "Corax"
}

await documentStore.maintenance.send(new PutIndexesOperation(indexDefinition));
```
</TabItem>
<TabItem value="Storing_text_attachments" label="Storing_text_attachments">
```js
// Prepare text as `Buffer` instances to be stored as attachments:
// ===============================================================
const byteArray1 = Buffer.from(
    "Supplies soft drinks, fruit juices, and flavored syrups to restaurants and retailers.",
    "utf-8");
const byteArray2 = Buffer.from(
    "Supplies fine dining restaurants with premium meats, cheeses, and wines across France.",
    "utf-8");
const byteArray3 = Buffer.from(
    "An American grocery chain known for its fresh produce, organic foods, and local meats.",
    "utf-8");
const byteArray4 = Buffer.from(
    "An Asian grocery store specializing in ingredients for Japanese and Thai cuisine.",
    "utf-8");
const byteArray5 = Buffer.from(
    "A rural general store offering homemade jams, fresh-baked bread, and locally crafted gifts.",
    "utf-8");

const session = store.openSession();

const company1 = await session.load("companies/11-A");
const company2 = await session.load("companies/26-A");
const company3 = await session.load("companies/32-A");
const company4 = await session.load("companies/41-A");
const company5 = await session.load("companies/43-A");

session.advanced.attachments.store(company1, "description.txt", byteArray1, "text/plain");
session.advanced.attachments.store(company2, "description.txt", byteArray2, "text/plain");
session.advanced.attachments.store(company3, "description.txt", byteArray3, "text/plain");
session.advanced.attachments.store(company4, "description.txt", byteArray4, "text/plain");
session.advanced.attachments.store(company5, "description.txt", byteArray5, "text/plain");

await session.saveChanges();
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Company_ documents whose attachment contains text similar to `"chinese food"`.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
const relevantCompanies = await session.query({ index: Companies_ByVector_FromTextAttachment })
    .vectorSearch(
        field => field.withField("vectorFromAttachment"),
        queryVector => queryVector.byText("chinese food"),
        {
            similarity: 0.8
        }
    )
    .waitForNonStaleResults()
    .all();
```
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
```js
const relevantCompanies = await session.advanced.rawQuery(`
    from index "Companies/ByVector/FromTextAttachment"
    where vector.search(vectorFromAttachment, $searchTerm, 0.8)`)
        .addParameter("searchTerm", "chinese food")
        .waitForNonStaleResults() 
        .all();
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
from index "Companies/ByVector/FromTextAttachment"
where vector.search(vectorFromAttachment, $searchTerm, 0.8)
{ "searchTerm" : "chinese food" }
```
</TabItem>
</Tabs>

You can now extract the text from the attachments of the resulting documents:

<TabItem value="extract_attachment_content" label="extract_attachment_content">
```js
// Extract text from the attachment of the first resulting document
// ================================================================

const company = relevantCompanies[0];
const attachment = await session.advanced.attachments.get(company, "description.txt");

const attachmentResult = await getAttachmentAsString(attachment);
console.log(`Attachment text: ${attachmentResult}`);
```
</TabItem>

## Indexing NUMERICAL attachments

* The following index defines a **vector field** named `vectorFromAttachment`.  

* It indexes embeddings generated from the numerical data stored in the `vector.raw` attachment.  
  This applies to all _Company_ documents that contain an attachment with that name.

* Each attachment contains raw numerical data in 32-bit floating-point format.  

<Tabs groupId='languageSyntax'>
<TabItem value="Index (C# LINQ)" label="Index (C# LINQ)">
```js
class Companies_ByVector_FromNumericalAttachment extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // Index-field 'vectorFromAttachment' will hold embeddings
        // generated from the NUMERICAL content in the attachments.
        this.map = `docs.Companies.Select(company => new {
            company = company,
            // Load the attachment from the document (ensure it is not null)
            attachment = this.LoadAttachment(company, "vector.raw")
        }).Where(this0 => this0.attachment != null).Select(this0 => new {
            // Index the attachment's content in the vector field
            vectorFromAttachment = this.CreateVector(this0.attachment.GetContentAsStream())
        })`

        // Configure the vector field:
        this.vectorField("vectorFromAttachment", {
            // Define the source embedding type
            sourceEmbeddingType: "Single",
            // Define the desired destination format within the index
            destinationEmbeddingType: "Single"
        });
    
        this.searchEngineType = "Corax";
    }
}
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```js
const indexDefinition = new IndexDefinition();

indexDefinition.name = "Companies/ByVector/FromNumericalAttachment";

indexDefinition.maps = [`
    from company in docs.Companies
    let attachment = LoadAttachment(company, "vector.raw")
    where attachment != null
    select new
    {
        vectorFromAttachment = CreateVector(attachment.GetContentAsStream())
    }
`]

indexDefinition.fields = {
    "vectorFromAttachment": {
        vector: {
            sourceEmbeddingType: "Single",
            destinationEmbeddingType: "Single"
        }
    }
};

indexDefinition.configuration = {
    "Indexing.Static.SearchEngineType": "Corax"
}
    
await documentStore.maintenance.send(new PutIndexesOperation(indexDefinition));
```
</TabItem>
<TabItem value="Storing_numerical_attachments" label="Storing_numerical_attachments">
```js
// These vectors are simple pre-computed embedding vectors with 32-bit floating-point values.
// Note: In a real scenario, embeddings would be generated by a model.
// ==========================================================================================
const v1 = new Float32Array([0.1, 0.2, 0.3, 0.4]);
const v2 = new Float32Array([0.1, 0.7, 0.8, 0.9]);
const v3 = new Float32Array([0.5, 0.6, 0.7, 0.8]);

// Prepare the embedding vectors as `Buffer` to be stored as attachments:
// ======================================================================
const buffer1 = Buffer.from(v1.buffer);
const buffer2 = Buffer.from(v2.buffer);
const buffer3 = Buffer.from(v3.buffer);

const session = store.openSession();

// Load existing Company documents from RavenDB's sample data:
// ===========================================================
const company1 = await session.load("companies/50-A");
const company2 = await session.load("companies/51-A");
const company3 = await session.load("companies/52-A");

// Store the attachments in the documents:
// ========================================
session.advanced.attachments.store(company1, "vector.raw", buffer1);
session.advanced.attachments.store(company2, "vector.raw", buffer2);
session.advanced.attachments.store(company3, "vector.raw", buffer3);

await session.saveChanges();    
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include _Company_ documents whose attachment contains vectors similar to the query vector.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
const similarCompanies  = await session.query({ index: Companies_ByVector_FromNumericalAttachment })
    .vectorSearch(
        field => field.withField("vectorFromAttachment"),
        queryVector => queryVector.byEmbedding([0.1, 0.2, 0.3, 0.4])
    )
    .waitForNonStaleResults()
    .all();
```
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
```js
const similarCompanies  = await session.advanced.rawQuery(`
    from index "Companies/ByVector/FromNumericalAttachment"
    where vector.search(vectorFromAttachment, $queryVector)`)
        .addParameter("queryVector", [0.1, 0.2, 0.3, 0.4])
        .waitForNonStaleResults()
        .all();
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
from index "Companies/ByVector/FromNumericalAttachment"
where vector.search(vectorFromAttachment, $queryVector)
{ "queryVector" : [0.1, 0.2, 0.3, 0.4] }
```
</TabItem>
</Tabs>

## Indexing ALL attachments

* The following index defines a vector field named `vectorFromAttachment`.

* It indexes embeddings generated from the numerical data stored in ALL attachments of all _Company_ documents.

<Tabs groupId='languageSyntax'>
<TabItem value="Index (C# LINQ)" label="Index (C# LINQ)">
```js
class Companies_ByVector_AllAttachments extends AbstractCsharpIndexCreationTask {
    constructor() {
        super();

        // Index-field 'vectorFromAttachment' will hold embeddings
        // generated from the NUMERICAL content of ALL attachments.
        this.map = `docs.Companies.Select(company => new {
            company = company,
            // Load ALL attachments from the document
            attachments = this.LoadAttachments(company)
        }).Select(this0 => new {
            // Index the attachments content in the vector field    
            vectorFromAttachment = 
                this.CreateVector(this0.attachments.Select(e => e.GetContentAsStream()))
        })`;

        // Configure the vector field:
        this.vectorField("vectorFromAttachment", {
            sourceEmbeddingType: "Single",
            destinationEmbeddingType: "Single"
        });

        this.searchEngineType = "Corax";
    }
}
```
</TabItem>
<TabItem value="IndexDefinition" label="IndexDefinition">
```js
const indexDefinition = new IndexDefinition();

indexDefinition.name = "Companies/ByVector/AllAttachments";

indexDefinition.maps = [`
    from company in docs.Companies
    let attachments = LoadAttachments(company)  
    select new
    {
        vectorFromAttachment =
            CreateVector(attachments.Select(e => e.GetContentAsStream()))
    }
`];

indexDefinition.fields = {
    "vectorFromAttachment": {
        vector: {
            sourceEmbeddingType: "Single", 
            destinationEmbeddingType: "Single"
        }
    }
};

indexDefinition.configuration = {
    "Indexing.Static.SearchEngineType": "Corax"
}  

await documentStore.maintenance.send(new PutIndexesOperation(indexDefinition));
```
</TabItem>
<TabItem value="Storing_numerical_attachments" label="Storing_numerical_attachments">
```js
// These vectors are simple pre-computed embedding vectors with 32-bit floating-point values.
// Note: In a real scenario, embeddings would be generated by a model.
// ==========================================================================================
const v1 = new Float32Array([0.1, 0.2, 0.3, 0.4]);
const v2 = new Float32Array([0.5, 0.6, 0.7, 0.8]);

const v3 = new Float32Array([-0.1, 0.2, -0.7, -0.8]);
const v4 = new Float32Array([0.3, -0.6, 0.9, -0.9]);

// Prepare the embedding vectors as `Buffer` to be stored as attachments:
// ======================================================================
const buffer1 = Buffer.from(v1.buffer);
const buffer2 = Buffer.from(v2.buffer);

const buffer3 = Buffer.from(v3.buffer);
const buffer4 = Buffer.from(v4.buffer);

const session = store.openSession();

// Load existing Company documents from RavenDB's sample data:
// ===========================================================
const company1 = await session.load("companies/70-A");
const company2 = await session.load("companies/71-A");

// Store multiple attachments in the documents:
// ============================================
session.advanced.attachments.store(company1, "vector1.raw", buffer1);
session.advanced.attachments.store(company1, "vector2.raw", buffer2);

session.advanced.attachments.store(company2, "vector1.raw", buffer3);
session.advanced.attachments.store(company2, "vector2.raw", buffer4);

await session.saveChanges();
```
</TabItem>
</Tabs>

Execute a vector search using the index:  
Results will include Company documents whose attachments contains vectors similar to the query vector.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
```js
const similarCompanies = await session.query({ index: Companies_ByVector_AllAttachments })
    .vectorSearch(
        field => field.withField("vectorFromAttachment"),
        queryVector => queryVector.byEmbedding([-0.1, 0.2, -0.7, -0.8])
    )
    .waitForNonStaleResults()
    .all();
```
</TabItem>
<TabItem value="RawQuery" label="RawQuery">
```js
const similarCompanies = await session.advanced.rawQuery(`
    from index "Companies/ByVector/AllAttachments"
    where vector.search(vectorFromAttachment, $queryVector)`)
        .addParameter("queryVector", [-0.1, 0.2, -0.7, -0.8])
        .waitForNonStaleResults()
        .all();
```
</TabItem>
<TabItem value="RQL" label="RQL">
```sql
from index "Companies/ByVector/AllAttachments"
where vector.search(vectorFromAttachment, $queryVector)
{ "queryVector" : [0.1, 0.2, -0.7, -0.8] }
```
</TabItem>
</Tabs>
