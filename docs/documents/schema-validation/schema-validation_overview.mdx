---
title: "Schema validation overview"
hide_table_of_contents: true
sidebar_label: "Overview"
sidebar_position: 0
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import LanguageSwitcher from "@site/src/components/LanguageSwitcher";
import LanguageContent from "@site/src/components/LanguageContent";

# Schema validation overview
<Admonition type="note" title="">

* A validation schema is a JSON object associated with a document collection that requires documents in the collection to be saved only if they comply with the schema constraints.  

* Validation is enforced when documents are saved directly and when they are added or modified through operations such as patching or ETL tasks.

* Validating document compliance during writing can help ensure data consistency (e.g., by preventing the saving of documents with missing required fields) and simplify read-time handling by preventing the need for additional checks and transformations.

* Schemas can be configured per collection using [Studio](../../documents/schema-validation/validate-schema/validate-schema_studio) or the [client API](../../documents/schema-validation/validate-schema/validate-schema_api).

* In this article:  
   * [The validation process](../../documents/schema-validation/schema-validation_overview#the-validation-process)  
   * [A list of operations that trigger validation](../../documents/schema-validation/schema-validation_overview#a-list-of-operations-that-trigger-validation)  
   * [Available constraints](../../documents/schema-validation/schema-validation_overview#available-constraints)  
   * [Considerations](../../documents/schema-validation/schema-validation_overview#considerations)
   * [Use cases](../../documents/schema-validation/schema-validation_overview#use-cases)

</Admonition>

## The validation process
RavenDB's schema validator is a server-side mechanism that checks documents against predefined schema constraints during write operations.  
The validation process takes place when a document is written, if a validation schema is associated with the document's collection.  

Validation is triggered both when a document is saved directly, and when it is added or modified during a [supported batch operation](../../documents/schema-validation/schema-validation_overview#a-list-of-operations-that-trigger-validation).  

#### When a document is saved directly (using `SaveChanges()`):  
* The database checks if a schema is associated with the document's collection.  
* If a schema exists, the document is validated against the schema.  
* If the document conforms with all constraints, it is saved.  
* If the document fails validation, the save operation is rejected with a detailed [SchemaValidationException](../../documents/schema-validation/validate-documents/validate-documents_api#schemavalidationexception-message).  

#### When a document is added or modified during a [supported batch operation](../../documents/schema-validation/schema-validation_overview#a-list-of-operations-that-trigger-validation):  
* Validation is applied during writing; this means that in the case of an ETL task, for example, validation will take place if enabled on the destination database.  
* The database checks if a schema is associated with the document's collection and, if so, validates the document against the schema.  
* If the document conforms with all schema constraints, it is saved and the operation continues.  
* If the document fails validation, a detailed [SchemaValidationException](../../documents/schema-validation/validate-documents/validate-documents_api#schemavalidationexception-message) is thrown, the document is not saved, and the entire batch operation is aborted.  

## A list of operations that trigger validation
Validation is triggered during writing by these operations:
* `session.SaveChanges` / `session.SaveChangesAsync`  
  Validates while directly committing staged document changes in the session to the database.  
* `ETL tasks`  
  Validates documents while transferring them using an Extract/Transform/Load process.  
* `PatchByQueryOperation`  
  Validates documents updated by a patch query.  
* `BulkInsert.StoreAsync`  
  Validates each document when performing a bulk insert operation.  
* `RevertRevisionsByIdOperation`  
  Validates documents when reverting to a previous revision.
* `Smuggler.ImportAsync` / `Smuggler.ImportDatabaseOperation`  
  Validates documents when importing data using the Smuggler tool.


Validation is **not** applied during these operations:  
* `Backup.RestoreDatabase`  
  Documents are restored from backup **without** validation.  
* `Replication`  
  Validation is **not** applied when replicating documents to cluster nodes or via external replication.  

## Available constraints
A validation schema can enforce these constraints on documents:  
* [Type](../../documents/schema-validation/validate-documents/validate-documents_api#type)  
* [Required Properties](../../documents/schema-validation/validate-documents/validate-documents_api#required)  
* [Constant Value](../../documents/schema-validation/validate-documents/validate-documents_api#const)  
* [Allowed Values](../../documents/schema-validation/validate-documents/validate-documents_api#enum)  
* [String Minimum Length](../../documents/schema-validation/validate-documents/validate-documents_api#minlength)  
* [String Maximum Length](../../documents/schema-validation/validate-documents/validate-documents_api#maxlength)  
* [Pattern (Regex)](../../documents/schema-validation/validate-documents/validate-documents_api#pattern)  
* [Number Minimum Value](../../documents/schema-validation/validate-documents/validate-documents_api#minimum)  
* [Number Maximum Value](../../documents/schema-validation/validate-documents/validate-documents_api#maximum)  
* [Array Minimum Items](../../documents/schema-validation/validate-documents/validate-documents_api#minitems)  
* [Array Maximum Items](../../documents/schema-validation/validate-documents/validate-documents_api#maxitems)  
* [Properties](../../documents/schema-validation/validate-documents/validate-documents_api#properties)  
* [patternProperties](../../documents/schema-validation/validate-documents/validate-documents_api#patternproperties)  
* [Additional Properties](../../documents/schema-validation/validate-documents/validate-documents_api#additionalproperties)  
* [Items](../../documents/schema-validation/validate-documents/validate-documents_api#items)  
* [Dependencies](../../documents/schema-validation/validate-documents/validate-documents_api#dependencies)  
* [Null](../../documents/schema-validation/validate-documents/validate-documents_api#null)  

## Considerations
Take note of the following considerations when applying schema validation.
* **Performance impact**:  
  Schema validation introduces additional processing during write operations. While this overhead is generally minimal, it can become significant with very large bulk operations or complex schemas. It's important to monitor performance and optimize schemas as needed.
* **Schema evolution**:  
  As application requirements change, schemas may need to be updated. Care should be taken to manage schema changes, especially in production environments, to avoid unintended validation failures.
* **Error handling**:  
  Applications should implement robust error handling to manage validation failures gracefully. This includes providing meaningful feedback to users or logging errors for further analysis.
* **Testing**:  
  Thoroughly test schemas and validation logic in development environments before deploying to production to ensure that they behave as expected.  

## Use cases
A few scenarios where schema validation can help are:  
* **Ensuring Required Fields**  
  E.g., preventing the saving of a user profile without an email address.  
* **Enforcing Data Types**  
  E.g., making sure that fields like “age” are always numbers and not accidentally saved as strings or other types.  
* **Restricting Allowed Values**  
  E.g., limiting a field (like “status”) to specific values like “active”, “inactive”, or “pending”, and rejecting any other input.  
* **Maintaining Consistent Structure in Arrays**  
  E.g., ensuring that every item in an array (like a list of order items) follows the same structure and contains all required properties.  
* **Preventing Invalid Data During Integrations**  
  E.g., blocking documents with unexpected or malformed data from being saved during ETL or API imports, to protect downstream systems.  