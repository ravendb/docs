import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<Admonition type="note" title="">

* Prior to this article, please refer to [Full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) to learn about the `Search` method.  

* **All capabilities** provided by `Search` with a dynamic query can also be used when querying a static-index.

* However, as opposed to making a dynamic search query where an auto-index is created for you,  
  when using a **static-index**:  

    * You must configure the index-field in which you want to search.  
      See examples below.  
      
    * You can configure which analyzer will be used to tokenize this field.  
      See [selecting an analyzer](../../../indexes/using-analyzers.mdx#selecting-an-analyzer-for-a-field).    
* In this article:
  * [Indexing single field for FTS](../../../indexes/querying/searching.mdx#indexing-single-field-for-fts)
  * [Indexing multiple fields for FTS](../../../indexes/querying/searching.mdx#indexing-multiple-fields-for-fts)
  * [Indexing all fields for FTS (using AsJson)](../../../indexes/querying/searching.mdx#indexing-all-fields-for-fts-(using-asjson))
  * [Boosting search results](../../../indexes/querying/searching.mdx#boosting-search-results)
  * [Searching with wildcards](../../../indexes/querying/searching.mdx#searching-with-wildcards)
      * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../../indexes/querying/searching.mdx#when-usingoror)
      * [When using a custom analyzer](../../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
      * [When using the Exact analyzer](../../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

</Admonition>
## Indexing single field for FTS

#### The index:

<TabItem value="index_1" label="index_1">
<CodeBlock language="csharp">
{`public class Employees_ByNotes :
    AbstractIndexCreationTask<Employee, Employees_ByNotes.IndexEntry>
\{
    // The IndexEntry class defines the index-fields
    public class IndexEntry
    \{
        public string EmployeeNotes \{ get; set; \}
    \}

    public Employees_ByNotes()
    \{
        // The 'Map' function defines the content of the index-fields
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeNotes = employee.Notes[0]
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeNotes'
        Index(x => x.EmployeeNotes, FieldIndexing.Search);
        
        // Optionally: Set your choice of analyzer for the index-field.
        // Here the text from index-field 'EmployeeNotes' will be tokenized by 'WhitespaceAnalyzer'.
        Analyze(x => x.EmployeeNotes, "WhitespaceAnalyzer");

        // Note:
        // If no analyzer is set then the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Query with Search:

* Use `Search` to make a full-text search when querying the index.  

* Refer to [Full-Text search with dynamic queries](../../../client-api/session/querying/text-search/full-text-search.mdx) for all available **Search options**,  
  such as using wildcards, searching for multiple terms, etc.

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
//
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the index
    .Query<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the index
    .DocumentQuery<Employees_ByNotes.IndexEntry, Employees_ByNotes>()
     // Call 'Search':
     // pass the index field that was configured for FTS and the term to search for.
    .Search(x => x.EmployeeNotes, "French")
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have 'French' in their 'Notes' field.
// 
// * Search is case-sensitive since field was indexed using the 'WhitespaceAnalyzer'
//   which preserves casing.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes"
where search(EmployeeNotes, "French")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing multiple fields for FTS

#### The index:

<TabItem value="index_2" label="index_2">
<CodeBlock language="csharp">
{`public class Employees_ByEmployeeData : 
    AbstractIndexCreationTask<Employee, Employees_ByEmployeeData.IndexEntry>
\{
    public class IndexEntry
    \{
        public object[] EmployeeData \{ get; set; \}
    \}

    public Employees_ByEmployeeData()
    \{
        Map = employees => from employee in employees
            select new IndexEntry()
            \{
                EmployeeData = new object[]
                \{
                    // Multiple document-fields can be indexed
                    // into the single index-field 'EmployeeData' 
                    employee.FirstName,
                    employee.LastName,
                    employee.Title,
                    employee.Notes
                \}
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'EmployeeData'
        Index(x => x.EmployeeData, FieldIndexing.Search);
        
        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
     // Query the static-index
    .Query<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .OfType<Employee>()
    .ToListAsync();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
     // Query the static-index
    .DocumentQuery<Employees_ByEmployeeData.IndexEntry, Employees_ByEmployeeData>()
    .OpenSubclause()
     // A logical OR is applied between the following two Search calls:
    .Search(x => x.EmployeeData, "Manager")
     // A logical AND is applied between the following two terms: 
    .Search(x => x.EmployeeData, "French Spanish", @operator: SearchOperator.And)
    .CloseSubclause()
    .OfType<Employee>()
    .ToList();

// * Results will contain all Employee documents that have:
//   ('Manager' in any of the 4 document-fields that were indexed)
//   OR 
//   ('French' AND 'Spanish' in any of the 4 document-fields that were indexed)
//                                                                                                                                                                                                                                                                                                                  
// * Search is case-insensitive since the default analyzer is used
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByEmployeeData"
where (search(EmployeeData, "Manager") or search(EmployeeData, "French Spanish", and))
`}
</CodeBlock>
</TabItem>
</Tabs>



## Indexing all fields for FTS (using AsJson)

* To search across ALL fields in a document without defining each one explicitly,
  use the `AsJson` method in the _Map_ function to extract all property values and index them in a single searchable field.

* This approach makes the index robust to changes in the document schema.  
  By calling `.Select(x => x.Value)` on the result of `AsJson(...)`, 
  the index automatically includes values from ALL existing and newly added properties 
  and there is no need to update the index when the document structure changes.

* <Admonition type="info" title="">
  This indexing method is supported only when using **Lucene** as the indexing engine.
  </Admonition>
#### The index:

<TabItem value="index_6" label="index_6">
<CodeBlock language="csharp">
{`public class Products_ByAllValues : 
    AbstractIndexCreationTask<Product, Products_ByAllValues.IndexEntry>
\{
    public class IndexEntry
    \{
        // This index field will contain all values from all properties in the document
        public string AllValues \{ get; set; \}
                
        // Note:
        // RavenDB seamlessly supports multi-value indexing on this field.
        // Even though the 'AllValues' index-field is declared as a 'string',
        // it can accept a collection of values, as defined in the Map function.
        // The engine treats the field as if it contains multiple strings
        // and indexes each one individually.
    \}

    public Products_ByAllValues()
    \{
        Map = products => from product in products
            select new
            \{
                // Use the 'AsJson' method to convert the document into a JSON-like structure
                // and call 'Select' to extract only the values of each property
                AllValues = AsJson(product).Select(x => x.Value)
            \};

        // Configure the index-field for FTS:
        // Set 'FieldIndexing.Search' on index-field 'AllValues'
        Index(x => x.AllValues, FieldIndexing.Search);
        
        // Note:
        // Since no analyzer is set, the default 'RavenStandardAnalyzer' is used.
        
        // Set the search engine type to Lucene:
        SearchEngineType = Raven.Client.Documents.Indexes.SearchEngineType.Lucene;
    \}
\}
`}
</CodeBlock>
</TabItem>
#### Sample query:

<Tabs groupId='languageSyntax'>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Product> products = session
    .Query<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToList();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Product> products = await asyncSession
    .Query<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToListAsync();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Product> products = session.Advanced
    .DocumentQuery<Products_ByAllValues.IndexEntry,
        Products_ByAllValues>()
    .Search(x => x.AllValues, "tofu")
    .OfType<Product>()
    .ToList();

// * Results will contain all Product documents that have 'tofu'
//   in ANY of their fields.
//
// * Search is case-insensitive since the default analyzer is used.
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Products/ByAllValues"
where search(AllValues, "tofu")
`}
</CodeBlock>
</TabItem>
</Tabs>



## Boosting search results

* In order to prioritize results, you can provide a boost value to the searched terms.  
  This can be applied by either of the following:

  * Add a boost value to the relevant index-field **inside the index definition**.  
    Refer to article [indexes - boosting](../../../indexes/boosting.mdx).

  * Add a boost value to the queried terms **at query time**.  
    Refer to article [Boost search results](../../../client-api/session/querying/text-search/boost-search-results.mdx).



## Searching with wildcards

* When making a full-text search with wildcards in the search terms, 
  the presence of wildcards (`*`) in the terms sent to the search engine is determined by the transformations applied by the
  [analyzer](../../../indexes/using-analyzers.mdx) used in the index.

* Note the different behavior in the following cases, as described below:  
  * [When using RavenStandardAnalyzer or StandardAnalyzer or NGramAnalyzer](../../../indexes/querying/searching.mdx#when-usingoror)
  * [When using a custom analyzer](../../../indexes/querying/searching.mdx#when-using-a-custom-analyzer)
  * [When using the Exact analyzer](../../../indexes/querying/searching.mdx#when-using-the-exact-analyzer)

* When using [Corax](../../../indexes/search-engine/corax.mdx) as the search engine,  
  this behavior will only apply to indexes that are newly created or have been reset.
<Admonition type="note" title="">

##### When using&nbsp;`RavenStandardAnalyzer`&nbsp;or`StandardAnalyzer`&nbsp;or&nbsp;`NGramAnalyzer`:
Usually, the same analyzer used to tokenize field content at **indexing time** is also used to process the terms provided in the **full-text search query**
before they are sent to the search engine to retrieve matching documents.

**However, in the following cases**:

* When making a [dynamic search query](../../../client-api/session/querying/text-search/full-text-search.mdx)
* or when querying a static index that uses the default [RavenStandardAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-search-analyzer)
* or when querying a static index that uses the [StandardAnalyzer](../../../indexes/using-analyzers.mdx#analyzers-that-remove-common-stop-words)
* or when querying a static index that uses the [NGramAnalyzer](../../../indexes/using-analyzers.mdx#analyzers-that-tokenize-according-to-the-defined-number-of-characters)

the queried terms in the _Search_ method are processed with the [LowerCaseKeywordAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-analyzer)  
before being sent to the search engine.

This analyzer does Not remove the `*`, so the terms are sent with `*`, as provided in the search terms.  
For example:  

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByNotes_usingDefaultAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByNotes_usingDefaultAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string EmployeeNotes { get; set; }
    }

    public Employees_ByNotes_usingDefaultAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                EmployeeNotes = employee.Notes[0]
            };

        // Configure the index-field for FTS:
        Index(x => x.EmployeeNotes, FieldIndexing.Search);

        // Since no analyzer is explicitly set
        // then the default 'RavenStandardAnalyzer' will be used at indexing time.
        
        // However, when making a search query with wildcards,
        // the 'LowerCaseKeywordAnalyzer' will be used to process the search terms
        // prior to sending them to the search engine. 
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToListAsync();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByNotes_usingDefaultAnalyzer.IndexEntry,
        Employees_ByNotes_usingDefaultAnalyzer>()
    
     // If you request to include explanations,
     // you can see the exact term that was sent to the search engine.
    .IncludeExplanations(out var explanations)
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.EmployeeNotes, "*rench")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents that have terms that end with 'rench'
// (e.g. French). 

// Checking the explanations, you can see that the search term 'rench'
// was sent to the search engine WITH the leading wildcard, i.e. '*rench'
// since the 'LowerCaseKeywordAnalyzer' is used in this case. 
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:*rench", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/usingDefaultAnalyzer"
where search(EmployeeNotes, "*rench")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using a custom analyzer:
* When setting a [custom analyzer](../../../indexes/using-analyzers.mdx#creating-custom-analyzers) in your index to tokenize field content,
  then when querying the index, the search terms in the query will be processed according to the **custom analyzer's logic**.

* The `*` will remain in the terms if the custom analyzer allows it.
  It is the userâ€™s responsibility to ensure that wildcards are not removed by the custom analyzer if they should be included in the query.

* Note:  
  An exception to the above is when the wildcard is used as a suffix in the search term (e.g. `Fren*`).  
  In this case the wildcard will be included in the query regardless of the analyzer's logic.

For example:  

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByNotes_usingCustomAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByNotes_usingCustomAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string EmployeeNotes { get; set; }
    }

    public Employees_ByNotes_usingCustomAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                EmployeeNotes = employee.Notes[0]
            };

        // Configure the index-field for FTS:
        Index(x => x.EmployeeNotes, FieldIndexing.Search);
        
        // Set a custom analyzer for the index-field:
        Analyze(x => x.EmployeeNotes, "CustomAnalyzers.RemoveWildcardsAnalyzer");
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Custom_analyzer" label="Custom_analyzer">
<CodeBlock language="csharp">
{`// The custom analyzer:
// ====================

const string RemoveWildcardsAnalyzer =
    @"
      using System.IO;
      using Lucene.Net.Analysis; 
      using Lucene.Net.Analysis.Standard;
      namespace CustomAnalyzers
      {
          public class RemoveWildcardsAnalyzer : StandardAnalyzer
          {
              public RemoveWildcardsAnalyzer() : base(Lucene.Net.Util.Version.LUCENE_30)
              {
              }

              public override TokenStream TokenStream(string fieldName, System.IO.TextReader reader)
              {
                   // Read input stream and remove wildcards (*)
                  string text = reader.ReadToEnd();
                  string processedText = RemoveWildcards(text);
                  StringReader newReader = new StringReader(processedText);
                  
                  return base.TokenStream(fieldName, newReader);
              }

              private string RemoveWildcards(string input)
              {
                  // Replace wildcard characters with an empty string
                  return input.Replace(""*"", """");
              }
          }
      }";

// Deploying the custom analyzer:
// ==============================

store.Maintenance.Send(new PutAnalyzersOperation(new AnalyzerDefinition()
{
    Name = "CustomAnalyzers.RemoveWildcardsAnalyzer",
    Code = RemoveWildcardsAnalyzer,
}));
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToList();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToListAsync();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByNotes_usingCustomAnalyzer.IndexEntry,
        Employees_ByNotes_usingCustomAnalyzer>()
    .IncludeExplanations(out var explanations)
     // Provide a term with wildcards to the Search method:
    .Search(x => x.EmployeeNotes, "*French*")
    .OfType<Employee>()
    .ToList();

// Even though a wildcard was provided,
// the results will contain only Employee documents that contain the exact term 'French'.

// The search term was sent to the search engine WITHOUT the wildcard,
// as the custom analyzer's logic strips them out.

// This can be verified by checking the explanations:
var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"EmployeeNotes:french", explanation);
Assert.DoesNotContain($"EmployeeNotes:*french", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByNotes/UsingCustomAnalyzer"
where search(EmployeeNotes, "*French*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>
<Admonition type="note" title="">

##### When using the Exact analyzer:
When using the default Exact analyzer in your index (which is [KeywordAnalyzer](../../../indexes/using-analyzers.mdx#using-the-default-exact-analyzer)),  
then when querying the index, the wildcards in your search terms remain untouched.  
The terms are sent to the search engine exactly as produced by the analyzer.

For example:

<Tabs groupId='languageSyntax'>
<TabItem value="Index" label="Index">
<CodeBlock language="csharp">
{`public class Employees_ByFirstName_usingExactAnalyzer :
    AbstractIndexCreationTask<Employee, Employees_ByFirstName_usingExactAnalyzer.IndexEntry>
{
    public class IndexEntry
    {
        public string FirstName { get; set; }
    }

    public Employees_ByFirstName_usingExactAnalyzer()
    {
        Map = employees => from employee in employees
            select new IndexEntry()
            {
                FirstName = employee.FirstName
            };
        
        // Set the Exact analyzer for the index-field:
        // (The field will not be tokenized)
        Indexes.Add(x => x.FirstName, FieldIndexing.Exact);
    }
}
`}
</CodeBlock>
</TabItem>
<TabItem value="Query" label="Query">
<CodeBlock language="csharp">
{`List<Employee> employees = session
    .Query<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="Query_async" label="Query_async">
<CodeBlock language="csharp">
{`List<Employee> employees = await asyncSession
    .Query<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    
    .ToDocumentQuery()
    .IncludeExplanations(out var explanations)
    .ToQueryable()
    
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToListAsync();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="DocumentQuery" label="DocumentQuery">
<CodeBlock language="csharp">
{`List<Employee> employees = session.Advanced
    .DocumentQuery<Employees_ByFirstName_usingExactAnalyzer.IndexEntry,
        Employees_ByFirstName_usingExactAnalyzer>()
    .IncludeExplanations(out var explanations)
     // Provide a term with a wildcard to the Search method:
    .Search(x => x.FirstName, "Mich*")
    .OfType<Employee>()
    .ToList();

// Results will contain all Employee documents with FirstName that starts with 'Mich'
// (e.g. Michael).

// The search term, 'Mich*', is sent to the search engine
// exactly as was provided to the Search method, WITH the wildcard.

var explanation = explanations.GetExplanations(employees[0].Id)[0];
Assert.Contains($"FirstName:Mich*", explanation);
`}
</CodeBlock>
</TabItem>
<TabItem value="RQL" label="RQL">
<CodeBlock language="sql">
{`from index "Employees/ByFirstName/usingExactAnalyzer"
where search(FirstName, "Mich*")
include explanations()
`}
</CodeBlock>
</TabItem>
</Tabs>

</Admonition>



